{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VideoTimestamps documentation","text":"<p>This tool allows recovering the timestamps of each frame in a video in any unit (seconds, milliseconds, nanoseconds, etc.). It also helps convert a frame to a time in any units and vice versa.</p>"},{"location":"#example-code","title":"Example code","text":"<pre><code>from fractions import Fraction\n\nfrom video_timestamps import FPSTimestamps, RoundingMethod, TimeType\n\nfps = Fraction(24000, 1001)\ntime_scale = Fraction(1000)\n# Read the documentation to find out which RoundingMethod suits your needs.\n# You can also create a ABCTimestamps instance with FPSTimestamps, VideoTimestamps or TextFileTimestamps\ntimestamps = FPSTimestamps(RoundingMethod.ROUND, time_scale, fps)\n\nframe = 10\n# Max precision\nstart_time_in_seconds = timestamps.frame_to_time(frame, TimeType.START)\nend_time_in_seconds = timestamps.frame_to_time(frame, TimeType.END)\nprint(f\"For the fps {fps}, the frame {frame} start at {start_time_in_seconds} s and end at {end_time_in_seconds} s.\")\n\n# Precision in milliseconds\nstart_time_in_ms = timestamps.frame_to_time(frame, TimeType.START, 3)\nend_time_in_ms = timestamps.frame_to_time(frame, TimeType.END, 3)\nprint(f\"For the fps {fps}, the frame {frame} start at {start_time_in_ms} ms and end at {end_time_in_ms} ms.\")\n</code></pre> <p>Output <pre><code>For the fps 24000/1001, the frame 10 start at 417/1000 s and end at 459/1000 s.\nFor the fps 24000/1001, the frame 10 start at 417 ms and end at 459 ms.\n</code></pre></p>"},{"location":"Algorithm%20conversion%20explanation/","title":"FPSTimestamps conversion explanation","text":""},{"location":"Algorithm%20conversion%20explanation/#introduction","title":"Introduction","text":"<p>To understand how <code>frame_to_time</code> and <code>time_to_frame</code> of <code>FPSTimestamps</code>, we need to fully understand how <code>TimeType</code> works.</p> <p>Here is an example of timestamps and their TimeType with a \\(fps = {24000 \\over 1001}\\), a \\(timebase = {1 \\over 1000}\\) and a \\(roundingMethod = \\text{ROUND}\\):</p> <p>Timestamps</p> \\[ \\begin{gather} \\text{Frame 0}: 0 \\text{ ms} \\\\ \\text{Frame 1}: 42 \\text{ ms} \\\\ \\text{Frame 2}: 83 \\text{ ms} \\\\ \\text{Frame 3}: 125 \\text{ ms} \\\\ \\text{Frame 4}: 167 \\text{ ms} \\\\ \\text{Frame 5}: 209 \\text{ ms} \\end{gather} \\] <p>EXACT</p> \\[ \\begin{gather} \\text{Frame 0}: [0, 42[ \\text{ ms} \\\\ \\text{Frame 1}: [42, 83[ \\text{ ms} \\\\ \\text{Frame 2}: [83, 167[ \\text{ ms} \\\\ \\text{Frame 3}: [167, 209[ \\text{ ms} \\\\ \\text{Frame 4}: [209, 250[ \\text{ ms} \\end{gather} \\] <p>START</p> \\[ \\begin{gather} \\text{Frame 0}:  0 \\text{ ms} \\\\ \\text{Frame 1}: ]0, 42] \\text{ ms} \\\\ \\text{Frame 2}: ]42, 83] \\text{ ms} \\\\ \\text{Frame 3}: ]83, 167] \\text{ ms} \\\\ \\text{Frame 4}: ]167, 209] \\text{ ms} \\end{gather} \\] <p>END</p> \\[ \\begin{gather} \\text{Frame 0}: ]0, 42] \\text{ ms} \\\\ \\text{Frame 1}: ]42, 83] \\text{ ms} \\\\ \\text{Frame 2}: ]83, 167] \\text{ ms} \\\\ \\text{Frame 3}: ]167, 209] \\text{ ms} \\\\ \\text{Frame 4}: ]209, 250] \\text{ ms} \\end{gather} \\] <p>The interval for each type of timing are defined like this:</p> \\[ \\begin{gather} \\text{EXACT : } [\\text{CurrentFrameTimestamps}, \\text{NextFrameTimestamps}[ \\\\ \\text{START : } ]\\text{PreviousFrameTimestamps} , \\text{CurrentFrameTimestamps}] \\\\ \\text{END : } ]\\text{CurrentFrameTimestamps}, \\text{NextFrameTimestamps}] \\end{gather} \\]"},{"location":"Algorithm%20conversion%20explanation/#frame_to_time","title":"frame_to_time","text":"<p>A lot of people think that the time can be calculated like this: \\(time= frame \\times {1 \\over fps}\\), but this is only a approximation. Actually, videos use this formula: \\(pts\\_time= pts \\times timebase\\). So, the \"real\" name for \\(time\\) is \\(pts\\_time\\), but note that, in some case, a video stream may not contains any \\(pts\\). In those case, in general, player fallback to \\(dts\\).</p> <p>Important to note:</p> \\[ \\begin{gather} pts \\in \\mathbb{N} \\\\ timebase \\in \\mathbb{Q}^{+} \\\\ pts\\_time \\in \\mathbb{Q} \\\\ \\end{gather} \\] <p>Source for pts</p> <p>Source for timebase</p> <p>But, how are \\(pts\\) and \\(timebase\\) setted?</p> <p>The \\(timebase\\) depend on the codec/container. For example, for .m2ts file, the \\(timebase\\) will always be \\({1 \\over 90000}\\). By default mkvtoolnix set the timebase to \\({1 \\over 1000}\\). Important to note that there is a really similar value to \\(timebase\\) called \\(timescale\\). It is defined like this:</p> \\[timescale = {1 \\over timebase}\\] <p>For the \\(pts\\), it is simple, \\(pts = \\text{roundingMethod}(frame \\times ticks)\\). The \\(\\text{roundingMethod}\\) depend on the implementation. For example, for .m2ts file, it will always be floored and mkvtoolnix will always round them. Note that the \\(ticks\\) is defined like this:</p> \\[ticks = {timescale \\over fps}\\] <p>So, in brief, the expended formula is:</p> <p>\\(time = pts \\times timebase\\)</p> <p>\\(time = {\\text{roundingMethod}(frame \\times ticks) \\over timescale}\\)</p> <p>\\(time = {\\text{roundingMethod}(frame \\times {timescale \\over fps}) \\over timescale}\\)</p> <p>This works, but it assume that the first frame start at PTS 0 which isn't necessary the case. To avoid this, we could do this:</p> <p>\\(time = {\\text{roundingMethod}(frame \\times {timescale \\over fps}) + first\\_pts \\over timescale}\\)</p> <p>But, to properly support v1 timestamps file, we need to do this:</p> <p>\\(time = {\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#frame_to_time-for-timetypeexact","title":"frame_to_time for TimeType.EXACT","text":"<p>\\(\\text{EXACT : } [\\text{CurrentFrameTimestamps}, \\text{NextFrameTimestamps}[\\)</p> <p>The lower bound is: \\(time = {\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p> <p>The upper bound is: \\(time = {\\text{roundingMethod}(({(frame + 1) \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#frame_to_time-for-timetypestart","title":"frame_to_time for TimeType.START","text":"<p>\\(\\text{START : } ]\\text{PreviousFrameTimestamps} , \\text{CurrentFrameTimestamps}]\\)</p> <p>The lower bound is: \\(time = {\\text{roundingMethod}(({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p> <p>The upper bound is: \\(time = {\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#frame_to_time-for-timetypeend","title":"frame_to_time for TimeType.END","text":"<p>\\(\\text{END : } ]\\text{CurrentFrameTimestamps}, \\text{NextFrameTimestamps}]\\)</p> <p>The lower bound is: \\(time = {\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p> <p>The upper bound is: \\(time = {\\text{roundingMethod}(({(frame + 1) \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#time_to_frame","title":"time_to_frame","text":""},{"location":"Algorithm%20conversion%20explanation/#time_to_frame-for-timetypeexact","title":"time_to_frame for TimeType.EXACT","text":"<p><code>time_to_frame</code> need to be exactly the inverse of <code>frame_to_time</code>. Since there are rounding operation, we cannot directly isolate it. To do so, we need to use the interval to our advantage. Here is a example:</p> \\[ \\begin{gather} fps = 24000/1001 \\\\ \\text{Frame 0}: [0, 42[ ms \\\\ \\text{Frame 1}: [42, 83[ ms \\\\ \\text{Frame 2}: [83, 125[ ms \\\\ \\text{Frame 3}: [125, 167[ ms \\end{gather} \\] <p>PS: The number are in milliseconds for simplicity, but actually, the formula give time in second.</p> <p>With that in mind, we know can say that the property says that we need to use the largest \\(frame\\) such that the \\(frame\\) does not exceed the requested \\(time\\).</p> <p>From that property, we can deduce this equation: \\({\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\over timescale} \\leq time\\)</p> <p>We can isolate our roundingMethod like this: \\(\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\leq time \\times timescale\\)</p> <p>Now, we have an inequation and it is possible to isolate properly our \\(frame\\) variable. Since the \\(\\text{roundingMethod}\\) can be floor or rounded, we will have 2 final equations that are described below:</p>"},{"location":"Algorithm%20conversion%20explanation/#explanation-for-rounding-method","title":"Explanation for rounding method","text":"<p>\\(\\text{round}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\leq time \\times timescale\\)</p> <p>\\(({frame \\over fps} + first\\_timestamps) \\times timescale &lt; \\lfloor time \\times timescale \\rfloor + 0.5\\)</p> <p>\\({frame \\over fps} + first\\_timestamps &lt; {\\lfloor time \\times timescale \\rfloor + 0.5 \\over timescale}\\)</p> <p>\\({frame \\over fps} &lt; {\\lfloor time \\times timescale \\rfloor + 0.5 \\over timescale} - first\\_timestamps\\)</p> <p>\\(frame &lt; ({\\lfloor time \\times timescale \\rfloor + 0.5 \\over timescale} - first\\_timestamps) \\times fps\\)</p> <p>\\(frame &lt; \\lceil ({\\lfloor time \\times timescale \\rfloor + 0.5 \\over timescale} - first\\_timestamps) \\times fps \\rceil\\)</p> <p>\\(frame \\leq \\lceil ({\\lfloor time \\times timescale \\rfloor + 0.5 \\over timescale} - first\\_timestamps) \\times fps \\rceil - 1\\)</p> <p>\\(frame = \\lceil ({\\lfloor time \\times timescale \\rfloor + 0.5 \\over timescale} - first\\_timestamps) \\times fps \\rceil - 1\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#explanation-for-floor-method","title":"Explanation for floor method","text":"<p>\\(\\lfloor ({frame \\over fps} + first\\_timestamps) \\times timescale \\rfloor \\leq time \\times timescale\\)</p> <p>\\(({frame \\over fps} + first\\_timestamps) \\times timescale &lt; \\lfloor time \\times timescale \\rfloor + 1\\)</p> <p>\\({frame \\over fps} + first\\_timestamps &lt; {\\lfloor time \\times timescale \\rfloor + 1 \\over timescale}\\)</p> <p>\\({frame \\over fps} &lt; {\\lfloor time \\times timescale \\rfloor + 1 \\over timescale} - first\\_timestamps\\)</p> <p>\\(frame &lt; ({\\lfloor time \\times timescale \\rfloor + 1 \\over timescale} - first\\_timestamps) \\times fps\\)</p> <p>\\(frame &lt; \\lceil ({\\lfloor time \\times timescale \\rfloor + 1 \\over timescale} - first\\_timestamps) \\times fps \\rceil\\)</p> <p>\\(frame \\leq \\lceil ({\\lfloor time \\times timescale \\rfloor + 1 \\over timescale} - first\\_timestamps) \\times fps \\rceil - 1\\)</p> <p>\\(frame = \\lceil ({\\lfloor time \\times timescale \\rfloor + 1 \\over timescale} - first\\_timestamps) \\times fps \\rceil - 1\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#time_to_frame-for-timetypestart","title":"time_to_frame for TimeType.START","text":"<p>\\(time = {\\text{roundingMethod}(({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p> <p>\\({\\text{roundingMethod}(({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale) \\over timescale} &lt; time\\)</p> <p>\\(\\text{roundingMethod}(({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale) &lt; time \\times timescale\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#explanation-for-rounding-method_1","title":"Explanation for rounding method","text":"<p>\\(\\text{round}(({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale) &lt; time \\times timescale\\)</p> <p>\\(({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale + 0.5 &lt; \\lceil time \\times timescale \\rceil\\)</p> <p>\\(({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale &lt; \\lceil time \\times timescale \\rceil - 0.5\\)</p> <p>\\({(frame - 1) \\over fps} + first\\_timestamps &lt; {\\lceil time \\times timescale \\rceil - 0.5 \\over timescale}\\)</p> <p>\\({(frame - 1) \\over fps} &lt; {\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps\\)</p> <p>\\(frame - 1 &lt; ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps\\)</p> <p>\\(frame &lt; ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps + 1\\)</p> <p>\\(frame &lt; \\lceil ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps + 1 \\rceil\\)</p> <p>\\(frame \\leq \\lceil ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps + 1 \\rceil - 1\\)</p> <p>\\(frame = \\lceil ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps + 1 \\rceil - 1\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#explanation-for-floor-method_1","title":"Explanation for floor method","text":"<p>\\(\\lfloor ({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale) \\rfloor &lt; time \\times timescale\\)</p> <p>\\(({(frame - 1) \\over fps} + first\\_timestamps) \\times timescale) &lt; \\lceil time \\times timescale \\rceil\\)</p> <p>\\({(frame - 1) \\over fps} + first\\_timestamps &lt; {\\lceil time \\times timescale \\rceil \\over timescale}\\)</p> <p>\\({(frame - 1) \\over fps} &lt; {\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps\\)</p> <p>\\(frame - 1 &lt; ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps\\)</p> <p>\\(frame &lt; ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps + 1\\)</p> <p>\\(frame &lt; \\lceil ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps + 1 \\rceil\\)</p> <p>\\(frame \\leq \\lceil ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps + 1 \\rceil - 1\\)</p> <p>\\(frame = \\lceil ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps + 1 \\rceil - 1\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#time_to_frame-for-timetypeend","title":"time_to_frame for TimeType.END","text":"<p>\\(time = {\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\over timescale}\\)</p> <p>\\({\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) \\over timescale} &lt; time\\)</p> <p>\\(\\text{roundingMethod}(({frame \\over fps} + first\\_timestamps) \\times timescale) &lt; time \\times timescale\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#explanation-for-rounding-method_2","title":"Explanation for rounding method","text":"<p>\\(\\text{round}(({frame \\over fps} + first\\_timestamps) \\times timescale) &lt; time \\times timescale\\)</p> <p>\\(({frame \\over fps} + first\\_timestamps) \\times timescale + 0.5 &lt; \\lceil time \\times timescale \\rceil\\)</p> <p>\\(({frame \\over fps} + first\\_timestamps) \\times timescale &lt; \\lceil time \\times timescale \\rceil - 0.5\\)</p> <p>\\({frame \\over fps} + first\\_timestamps &lt; {\\lceil time \\times timescale \\rceil - 0.5 \\over timescale}\\)</p> <p>\\({frame \\over fps} &lt; {\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps\\)</p> <p>\\(frame &lt; ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps\\)</p> <p>\\(frame &lt; \\lceil ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps \\rceil\\)</p> <p>\\(frame \\leq \\lceil ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps \\rceil - 1\\)</p> <p>\\(frame = \\lceil ({\\lceil time \\times timescale \\rceil - 0.5 \\over timescale} - first\\_timestamps) \\times fps \\rceil - 1\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#explanation-for-floor-method_2","title":"Explanation for floor method","text":"<p>\\(\\lfloor({frame \\over fps} + first\\_timestamps) \\times timescale \\rfloor &lt; time \\times timescale\\)</p> <p>\\(({frame \\over fps} + first\\_timestamps) \\times timescale &lt; \\lceil time \\times timescale \\rceil\\)</p> <p>\\({frame \\over fps} + first\\_timestamps &lt; {\\lceil time \\times timescale \\rceil \\over timescale}\\)</p> <p>\\({frame \\over fps} &lt; {\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps\\)</p> <p>\\(frame &lt; ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps\\)</p> <p>\\(frame &lt; \\lceil ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps \\rceil\\)</p> <p>\\(frame \\leq \\lceil ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps \\rceil - 1\\)</p> <p>\\(frame = \\lceil ({\\lceil time \\times timescale \\rceil \\over timescale} - first\\_timestamps) \\times fps \\rceil - 1\\)</p>"},{"location":"Algorithm%20conversion%20explanation/#acknowledgments","title":"Acknowledgments","text":"<p>Thanks to arch1t3cht who helped me understand the math behind this conversion.</p>"},{"location":"Extract%20timestamps%20from%20video/","title":"Extract timestamps from video","text":""},{"location":"Extract%20timestamps%20from%20video/#usage","title":"Usage","text":"<pre><code>$ extracttimestamps --help\nusage: extracttimestamps [-h] [-o OUTPUT] [-i INDEX] [-n] [-vp {ffms2,bestsource}] [--precision PRECISION] [--precision-rounding {floor,round,ceil}] [--use-fraction] video\n\nVideo timestamps extractor.\n\npositional arguments:\n  video                 Path to the video file to extract timestamps from.\n\noptions:\n  -h, --help            show this help message and exit\n  -o, --output OUTPUT   Path to save the timestamps file. By default, it will be saved in the same directory as the video with the video name and index. Example: For \"video.mkv\" and --index 1, it will be \"video_1.txt\".\n  -i, --index INDEX     Index of the track to extract timestamps from (default: 0).\n  -n, --normalize       If specified, shift the timestamps to make them start from 0.\n  -vp, --video-provider {ffms2,bestsource}\n                        Video provider to use for timestamps extraction (default: ffms2).\n  --precision PRECISION\n                        Number of decimal places for timestamps (default: 9). Common values: - 3 means milliseconds - 6 means microseconds - 9 means nanoseconds\n  --precision-rounding {floor,round,ceil}\n                        Rounding method to use for timestamps (default: round). Examples: - Timestamp: 453.4 ms, --precision 3, --precision-rounding round --&gt; 453 - Timestamp: 453.4569 ms, --precision 6, --precision-rounding round --&gt; 453.457\n  --use-fraction        If specified, the timestamps produced will be represented has a fraction (ex: \"30/2\") instead of decimal (ex: \"3.434\"). Note that this is not a conform to the specification.\n</code></pre>"},{"location":"reference/abc_timestamps/","title":"ABCTimestamps","text":"<p>               Bases: <code>ABC</code></p> <p>Timestamps object contains informations about the timestamps of an video. Constant Frame Rate (CFR) and Variable Frame Rate (VFR) videos are supported.</p> <p>Depending of the software you use to create the video, the PTS (Presentation Time Stamp) may be rounded of floored.</p> <p>In general, the PTS are floored, so you should use <code>RoundingMethod.FLOOR</code>.</p> <p>But, Matroska (.mkv) file are an exception because they are rounded. If you want to be compatible with mkv, use <code>RoundingMethod.ROUND</code>. By default, they only have a precision to milliseconds instead of nanoseconds like most format.</p> For more detail see <ol> <li>mkvmerge timestamp scale documentation</li> <li>Matroska timestamp scale rounding notes</li> </ol> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>class ABCTimestamps(ABC):\n    \"\"\"Timestamps object contains informations about the timestamps of an video.\n    Constant Frame Rate (CFR) and Variable Frame Rate (VFR) videos are supported.\n\n    Depending of the software you use to create the video, the PTS (Presentation Time Stamp)\n    may be rounded of floored.\n\n    In general, the PTS are floored, so you should use [`RoundingMethod.FLOOR`][video_timestamps.rounding_method.RoundingMethod.FLOOR].\n\n    But, Matroska (.mkv) file are an exception because they are rounded.\n    If you want to be compatible with mkv, use [`RoundingMethod.ROUND`][video_timestamps.rounding_method.RoundingMethod.ROUND].\n    By default, they only have a precision to milliseconds instead of nanoseconds like most format.\n\n    For more detail see:\n        1. [mkvmerge timestamp scale documentation](https://mkvtoolnix.download/doc/mkvmerge.html#mkvmerge.description.timestamp_scale)\n        2. [Matroska timestamp scale rounding notes](https://www.matroska.org/technical/notes.html#timestampscale-rounding)\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def fps(self) -&gt; Fraction:\n        \"\"\"\n        Returns:\n            The framerate of the video.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def time_scale(self) -&gt; Fraction:\n        \"\"\"\n        Returns:\n            Unit of time (in seconds) in terms of which frame PTS are represented.\n\n                **Important**: Don't confuse time_scale with the time_base. As a reminder, time_base = 1 / time_scale.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def first_timestamps(self) -&gt; Fraction:\n        \"\"\"\n        Returns:\n            Time (in seconds) of the first frame of the video.\n\n                **Warning**: Depending on the subclass, the first_timestamps may not be rounded, so it won't really be first_timestamps.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _time_to_frame(\n        self,\n        time: Fraction,\n        time_type: TimeType,\n    ) -&gt; int:\n        pass\n\n    def time_to_frame(\n        self,\n        time: int | Fraction,\n        time_type: TimeType,\n        input_unit: int | None = None\n    ) -&gt; int:\n        \"\"\"Converts a given time value into the corresponding frame number based on the specified time type.\n\n        Parameters:\n            time: The time value to convert.\n\n                - If `time` is an int, the unit of the value is specified by `input_unit` parameter.\n\n                - If `time` is a Fraction, the value is expected to be in seconds.\n            time_type: The type of timing to use for conversion.\n            input_unit: The unit of the `time` parameter when it is an int.\n                Must be a non-negative integer if specified.\n\n                Common values:\n\n                - 3 means milliseconds\n                - 6 means microseconds\n                - 9 means nanoseconds\n\n                If None, the `time` will be a Fraction representing seconds.\n\n        Returns:\n            The corresponding frame number for the given time.\n\n        Examples:\n            &gt;&gt;&gt; timestamps.time_to_frame(50, TimeType.START, 3)\n            2\n            &gt;&gt;&gt; timestamps.time_to_frame(Fraction(50/1000), TimeType.START)\n            2\n            # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n        \"\"\"\n\n        if input_unit is None:\n            if not isinstance(time, Fraction):\n                raise ValueError(\"If input_unit is none, the time needs to be a Fraction.\")\n            time_in_second = time\n        else:\n            if not isinstance(time, int):\n                raise ValueError(\"If you specify a input_unit, the time needs to be a int.\")\n\n            if input_unit &lt; 0:\n                raise ValueError(\"The input_unit needs to be above or equal to 0.\")\n\n            time_in_second = time * Fraction(1, 10 ** input_unit)\n\n        first_timestamps = self.frame_to_time(0, TimeType.EXACT)\n\n        if time_in_second &lt; first_timestamps and time_type == TimeType.EXACT:\n            raise ValueError(f\"You cannot specify a time under the first timestamps {first_timestamps} with the TimeType.EXACT.\")\n        if time_in_second &lt;= first_timestamps:\n            if time_type == TimeType.START:\n                return 0\n            elif time_type == TimeType.END:\n                raise ValueError(f\"You cannot specify a time under or equals the first timestamps {first_timestamps} with the TimeType.END.\")\n\n        frame = self._time_to_frame(time_in_second, time_type)\n        return frame\n\n\n    @abstractmethod\n    def _frame_to_time(\n        self,\n        frame: int,\n    ) -&gt; Fraction:\n        pass\n\n    @overload\n    def frame_to_time(\n        self,\n        frame: int,\n        time_type: TimeType,\n        output_unit: None = None,\n        center_time: bool = False,\n    ) -&gt; Fraction:\n        ...\n\n    @overload\n    def frame_to_time(\n        self,\n        frame: int,\n        time_type: TimeType,\n        output_unit: int,\n        center_time: bool = False,\n    ) -&gt; int:\n        ...\n\n    def frame_to_time(\n        self,\n        frame: int,\n        time_type: TimeType,\n        output_unit: int | None = None,\n        center_time: bool = False,\n    ) -&gt; int | Fraction:\n        \"\"\"Converts a given frame number into the corresponding time value based on the specified time type.\n\n        Parameters:\n            frame: The frame number to convert.\n            time_type: The type of timing to use for conversion.\n            output_unit: The unit of the output time value.\n                Must be a non-negative integer if specified.\n\n                Common values:\n\n                - 3 means milliseconds\n                - 6 means microseconds\n                - 9 means nanoseconds\n\n                If None, the output will be a Fraction representing seconds.\n            center_time: If True, the output time will represent the time at the center of two frames.\n                This option is only applicable when `time_type` is either [`TimeType.START`][video_timestamps.time_type.TimeType.START] or [`TimeType.END`][video_timestamps.time_type.TimeType.END].\n\n        Returns:\n            The corresponding time for the given frame number.\n\n        Examples:\n            &gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START, 3)\n            83\n            &gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START)\n            7507/90000\n            &gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START, 3, True)\n            63\n            # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n        \"\"\"\n\n        if output_unit is not None and output_unit &lt; 0:\n            raise ValueError(\"The output_unit needs to be above or equal to 0.\")\n\n        if frame &lt; 0:\n            raise ValueError(\"You cannot specify a frame under 0.\")\n\n        if time_type == TimeType.EXACT and center_time:\n            raise ValueError(\"It doesn't make sense to use the time in the center of two frame for TimeType.EXACT.\")\n\n        if time_type == TimeType.START:\n            upper_bound = self._frame_to_time(frame)\n\n            if center_time and frame &gt; 0:\n                lower_bound = self._frame_to_time(frame - 1)\n                time = (lower_bound + upper_bound) / 2\n            else:\n                time = upper_bound\n        elif time_type == TimeType.END:\n            upper_bound = self._frame_to_time(frame + 1)\n\n            if center_time:\n                lower_bound = self._frame_to_time(frame)\n                time = (lower_bound + upper_bound) / 2\n            else:\n                time = upper_bound\n        elif time_type == TimeType.EXACT:\n            time = self._frame_to_time(frame)\n        else:\n            raise ValueError(f'The TimeType \"{time_type}\" isn\\'t supported.')\n\n        if output_unit is None:\n            return time\n\n        if time_type == TimeType.EXACT:\n            time_output = ceil(time * Fraction(10) ** output_unit)\n        elif center_time and not (time_type == TimeType.START and frame == 0):\n            time_output = RoundingMethod.ROUND(time * 10 ** output_unit)\n        else:\n            time_output = floor(time * Fraction(10) ** output_unit)\n\n        result_frame = self.time_to_frame(time_output, time_type, output_unit)\n\n        if frame != result_frame:\n            raise ValueError(\n                f\"The frame {frame} cannot be represented exactly at output_unit={output_unit}. \"\n                f\"The conversion gave the time {time_output} which correspond to the frame {result_frame} which is different then {frame}. \"\n                f\"Try using a finer output_unit then {time_output}.\"\n            )\n\n        return time_output\n\n\n    def pts_to_frame(\n        self,\n        pts: int,\n        time_type: TimeType,\n        time_scale: Fraction | None = None\n    ) -&gt; int:\n        \"\"\"Converts a given PTS into the corresponding frame number based on the specified time type.\n\n        Parameters:\n            pts: The Presentation Time Stamp value to convert.\n            time_type: The type of timing to use for conversion.\n            time_scale: The time scale to interpret the `pts` parameter.\n                If None, it is assumed that the `pts` parameter uses the same time scale as the Timestamps object.\n\n        Returns:\n            The corresponding frame number for the given PTS.\n\n        Examples:\n            &gt;&gt;&gt; timestamps.pts_to_frame(7507, TimeType.START, Fraction(90000))\n            2\n            # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n        \"\"\"\n\n        if time_scale is None:\n            time = pts / self.time_scale\n        else:\n            time = pts / time_scale\n\n        frame = self.time_to_frame(time, time_type)\n        return frame\n\n\n    def frame_to_pts(\n        self,\n        frame: int,\n        time_type: TimeType,\n        time_scale: Fraction | None = None\n    ) -&gt; int:\n        \"\"\"Converts a given frame number into the corresponding PTS based on the specified time type.\n\n        Parameters:\n            frame: The frame number to convert.\n            time_type: The type of timing to use for conversion.\n            time_scale: The time scale to interpret the `pts` parameter.\n                If None, it is assumed that the `pts` parameter uses the same time scale as the Timestamps object.\n\n        Returns:\n            The corresponding PTS for the given frame number.\n\n        Examples:\n            &gt;&gt;&gt; timestamps.frame_to_pts(2, TimeType.START, Fraction(90000))\n            7507\n            # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n        \"\"\"\n\n        time = self.frame_to_time(frame, time_type)\n\n        round_pts_method: Callable[[Fraction], int]\n        if time_type == TimeType.EXACT:\n            round_pts_method = ceil\n        else:\n            round_pts_method = floor\n\n        if time_scale is None:\n            pts = time * self.time_scale\n            if pts != round_pts_method(pts):\n                raise ValueError(f\"An unexpected error occured. The generated pts {pts} isn't an integer. The requested frame is {frame} and the requested time_type is {time_type}. The object is {repr(self)}. Please, open an issue on GitHub.\")\n        else:\n            pts = time * time_scale\n\n        return round_pts_method(pts)\n\n\n    @overload\n    def move_time_to_frame(\n        self,\n        time: int | Fraction,\n        time_type: TimeType,\n        output_unit: None,\n        input_unit: int | None = None,\n        center_time: bool = False\n    ) -&gt; Fraction:\n        ...\n\n    @overload\n    def move_time_to_frame(\n        self,\n        time: int | Fraction,\n        time_type: TimeType,\n        output_unit: int,\n        input_unit: int | None = None,\n        center_time: bool = False\n    ) -&gt; int:\n        ...\n\n    def move_time_to_frame(\n        self,\n        time: int | Fraction,\n        time_type: TimeType,\n        output_unit: int | None = None,\n        input_unit: int | None = None,\n        center_time: bool = False\n    ) -&gt; int | Fraction:\n        \"\"\"\n        Moves the time to the corresponding frame time.\n        It is something close to using \"CTRL + 3\" and \"CTRL + 4\" on Aegisub.\n\n        Parameters:\n            time: The time value to convert.\n\n                - If `time` is an int, the unit of the value is specified by `input_unit` parameter.\n\n                - If `time` is a Fraction, the value is expected to be in seconds.\n            time_type: The type of timing to use for conversion.\n            output_unit: The unit of the output time value.\n                Must be a non-negative integer if specified.\n\n                Common values:\n\n                - 3 means milliseconds\n                - 6 means microseconds\n                - 9 means nanoseconds\n\n                If None, the output will be a Fraction representing seconds.\n            input_unit: The unit of the `time` parameter when it is an int.\n                Must be a non-negative integer if specified.\n\n                Common values:\n\n                - 3 means milliseconds\n                - 6 means microseconds\n                - 9 means nanoseconds\n\n                If None, the `time` will be a Fraction representing seconds.\n            center_time: If True, the output time will represent the time at the center of two frames.\n                This option is only applicable when `time_type` is either [`TimeType.START`][video_timestamps.time_type.TimeType.START] or [`TimeType.END`][video_timestamps.time_type.TimeType.END].\n\n        Returns:\n            The output represents `time` moved to the frame time.\n\n        Examples:\n            &gt;&gt;&gt; timestamps.move_time_to_frame(50, TimeType.START, 3, 3)\n            83\n            &gt;&gt;&gt; timestamps.move_time_to_frame(50, TimeType.START, 9, 3)\n            83411111\n            # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n        \"\"\"\n\n        return self.frame_to_time(self.time_to_frame(time, time_type, input_unit), time_type, output_unit, center_time)\n\n\n    def pts_to_time(\n        self,\n        pts: int,\n        time_type: TimeType,\n        output_unit: int,\n        time_scale: Fraction | None = None\n    ) -&gt; int:\n        \"\"\"\n        Converts a given PTS into the corresponding time, ensuring that\n        the resulting value corresponds to the same frame.\n\n        Parameters:\n            pts: The Presentation Time Stamp value to convert.\n            time_type: The type of timing to use for conversion.\n            time_scale: The time scale to interpret the `pts` parameter.\n                If None, it is assumed that the `pts` parameter uses the same time scale as the Timestamps object.\n\n        Returns:\n            The corresponding time for the given PTS.\n\n        Examples:\n            &gt;&gt;&gt; timestamps.pts_to_time(7507, TimeType.START, 3, Fraction(90000))\n            83\n            &gt;&gt;&gt; timestamps.pts_to_time(7507, TimeType.START, 9, Fraction(90000))\n            83411111\n            # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n        \"\"\"\n\n        if time_scale is None:\n            time = pts / self.time_scale\n        else:\n            time = pts / time_scale\n\n        return self.time_to_time(time, time_type, output_unit)\n\n\n    @overload\n    def time_to_pts(\n        self,\n        time: int,\n        time_type: TimeType,\n        input_unit: int,\n        time_scale: Fraction | None = None,\n    ) -&gt; int:\n        ...\n\n    @overload\n    def time_to_pts(\n        self,\n        time: Fraction,\n        time_type: TimeType,\n        input_unit: None = None,\n        time_scale: Fraction | None = None,\n    ) -&gt; int:\n        ...\n\n    def time_to_pts(\n        self,\n        time: int | Fraction,\n        time_type: TimeType,\n        input_unit: int | None = None,\n        time_scale: Fraction | None = None,\n    ) -&gt; int:\n        \"\"\"\n        Converts a given time value into the corresponding PTS, ensuring that\n        the resulting value corresponds to the same frame.\n\n        Parameters:\n            time: The time value to convert.\n\n                - If `time` is an int, the unit of the value is specified by `input_unit` parameter.\n\n                - If `time` is a Fraction, the value is expected to be in seconds.\n            time_type: The type of timing to use for conversion.\n            input_unit: The unit of the `time` parameter when it is an int.\n                Must be a non-negative integer if specified.\n\n                Common values:\n\n                - 3 means milliseconds\n                - 6 means microseconds\n                - 9 means nanoseconds\n\n                If None, the `time` will be a `Fraction` representing seconds.\n            time_scale: The time scale to interpret the `pts` that will be returned by this function.\n                - If None, the `pts` that will be returned will uses the same time scale as the Timestamps object.\n\n        Returns:\n            The corresponding PTS for the given time.\n\n        Examples:\n            &gt;&gt;&gt; timestamps.time_to_pts(83, TimeType.START, 3, Fraction(90000))\n            7470\n            &gt;&gt;&gt; timestamps.time_to_pts(83411111, TimeType.START, 9, Fraction(90000))\n            7507\n            # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n        \"\"\"\n\n        if input_unit is None:\n            time_in_second = time\n        else:\n            time_in_second = time * Fraction(1, 10 ** input_unit)\n\n        if time_scale is None:\n            output_time_scale = self.time_scale\n        else:\n            output_time_scale = time_scale\n\n        frame = self.time_to_frame(time, time_type, input_unit)\n        pts_output = time_in_second * output_time_scale\n\n        # Try with round first because we want to get the closest result\n        pts_output_round = RoundingMethod.ROUND(pts_output)\n        frame_round = self.pts_to_frame(pts_output_round, time_type, output_time_scale)\n        if frame_round == frame:\n            return pts_output_round\n\n        # Try with the opposite of round\n        pts_output_other = floor(pts_output) if pts_output_round == ceil(pts_output) else ceil(pts_output)\n        frame_other = self.pts_to_frame(pts_output_other, time_type, output_time_scale)\n        if frame_other == frame:\n            return pts_output_other\n\n        raise ValueError(f\"It is not possible to convert the time {time_in_second} to a PTS with a timescale of {output_time_scale} accurately.\")\n\n\n    @overload\n    def time_to_time(\n        self,\n        time: int,\n        time_type: TimeType,\n        output_unit: int,\n        input_unit: int,\n    ) -&gt; int:\n        ...\n\n    @overload\n    def time_to_time(\n        self,\n        time: Fraction,\n        time_type: TimeType,\n        output_unit: int,\n        input_unit: None = None,\n    ) -&gt; int:\n        ...\n\n    def time_to_time(\n        self,\n        time: int | Fraction,\n        time_type: TimeType,\n        output_unit: int,\n        input_unit: int | None = None,\n    ) -&gt; int:\n        \"\"\"\n        Converts a given time value from one unit to another, ensuring that\n        the resulting value corresponds to the same frame.\n\n        Parameters:\n            time: The time value to convert.\n\n                - If `time` is an int, the unit of the value is specified by `input_unit` parameter.\n\n                - If `time` is a Fraction, the value is expected to be in seconds.\n            time_type: The type of timing to use for conversion.\n            output_unit: The unit of the output time value.\n                Must be a non-negative integer.\n\n                Common values:\n\n                - 3 means milliseconds\n                - 6 means microseconds\n                - 9 means nanoseconds\n            input_unit: The unit of the `time` parameter when it is an `int`.\n                - Must be a non-negative integer if specified.\n\n                Common values:\n\n                - 3 means milliseconds\n                - 6 means microseconds\n                - 9 means nanoseconds\n\n                If None, the `time` will be a `Fraction` representing seconds.\n\n        Returns:\n            The converted time value expressed in `output_unit`.\n\n        Examples:\n            &gt;&gt;&gt; timestamps.time_to_time(83411111, TimeType.START, 3, 9)\n            83\n            &gt;&gt;&gt; timestamps.time_to_time(83411112, TimeType.START, 3, 9)\n            84\n            # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n        \"\"\"\n        if input_unit is not None and input_unit &lt; 0:\n            raise ValueError(\"The input_unit needs to be above or equal to 0.\")\n\n        if output_unit &lt; 0:\n            raise ValueError(\"The output_unit needs to be above or equal to 0.\")\n\n        if input_unit == output_unit and isinstance(time, int): # Just to make mypy happy, use isinstance so it doesn't report int | Fraction.\n            return time\n        elif input_unit is not None and input_unit &lt; output_unit:\n            return RoundingMethod.ROUND(time * 10 ** (output_unit - input_unit)) # Just to make mypy happy, round the result, but it is impossible to get a float from this.\n        else:\n            frame = self.time_to_frame(time, time_type, input_unit)\n            if isinstance(time, int) and input_unit is not None: # Just to make mypy happy, verify if input_unit is not None even if it can't.\n                time_output = Fraction(time, 10 ** (input_unit - output_unit))\n            else:\n                time_output = time * Fraction(10 ** output_unit)\n\n            # Try with round first because we want to get the closest result\n            time_output_round = RoundingMethod.ROUND(time_output)\n            try:\n                frame_round = self.time_to_frame(time_output_round, time_type, output_unit)\n            except ValueError:\n                frame_round = None\n            if frame_round == frame:\n                return time_output_round\n\n            # Try with the opposite of round\n            time_output_other = floor(time_output) if time_output_round == ceil(time_output) else ceil(time_output)\n            try:\n                frame_other = self.time_to_frame(time_output_other, time_type, output_unit)\n            except ValueError:\n                frame_other = None\n            if frame_other == frame:\n                return time_output_other\n\n            raise ValueError(f\"It is not possible to convert the time {time} from {input_unit} to {output_unit} accurately.\")\n\n\n    @abstractmethod\n    def __eq__(self, other: object) -&gt; bool:\n        pass\n\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        pass\n</code></pre>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.fps","title":"<code>fps</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>Fraction</code> <p>The framerate of the video.</p>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.time_scale","title":"<code>time_scale</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>Fraction</code> <p>Unit of time (in seconds) in terms of which frame PTS are represented.</p> <p>Important: Don't confuse time_scale with the time_base. As a reminder, time_base = 1 / time_scale.</p>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.first_timestamps","title":"<code>first_timestamps</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>Fraction</code> <p>Time (in seconds) of the first frame of the video.</p> <p>Warning: Depending on the subclass, the first_timestamps may not be rounded, so it won't really be first_timestamps.</p>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.time_to_frame","title":"<code>time_to_frame(time, time_type, input_unit=None)</code>","text":"<p>Converts a given time value into the corresponding frame number based on the specified time type.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int | Fraction</code> <p>The time value to convert.</p> <ul> <li> <p>If <code>time</code> is an int, the unit of the value is specified by <code>input_unit</code> parameter.</p> </li> <li> <p>If <code>time</code> is a Fraction, the value is expected to be in seconds.</p> </li> </ul> required <code>time_type</code> <code>TimeType</code> <p>The type of timing to use for conversion.</p> required <code>input_unit</code> <code>int | None</code> <p>The unit of the <code>time</code> parameter when it is an int. Must be a non-negative integer if specified.</p> <p>Common values:</p> <ul> <li>3 means milliseconds</li> <li>6 means microseconds</li> <li>9 means nanoseconds</li> </ul> <p>If None, the <code>time</code> will be a Fraction representing seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The corresponding frame number for the given time.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timestamps.time_to_frame(50, TimeType.START, 3)\n2\n&gt;&gt;&gt; timestamps.time_to_frame(Fraction(50/1000), TimeType.START)\n2\n# Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n</code></pre> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>def time_to_frame(\n    self,\n    time: int | Fraction,\n    time_type: TimeType,\n    input_unit: int | None = None\n) -&gt; int:\n    \"\"\"Converts a given time value into the corresponding frame number based on the specified time type.\n\n    Parameters:\n        time: The time value to convert.\n\n            - If `time` is an int, the unit of the value is specified by `input_unit` parameter.\n\n            - If `time` is a Fraction, the value is expected to be in seconds.\n        time_type: The type of timing to use for conversion.\n        input_unit: The unit of the `time` parameter when it is an int.\n            Must be a non-negative integer if specified.\n\n            Common values:\n\n            - 3 means milliseconds\n            - 6 means microseconds\n            - 9 means nanoseconds\n\n            If None, the `time` will be a Fraction representing seconds.\n\n    Returns:\n        The corresponding frame number for the given time.\n\n    Examples:\n        &gt;&gt;&gt; timestamps.time_to_frame(50, TimeType.START, 3)\n        2\n        &gt;&gt;&gt; timestamps.time_to_frame(Fraction(50/1000), TimeType.START)\n        2\n        # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n    \"\"\"\n\n    if input_unit is None:\n        if not isinstance(time, Fraction):\n            raise ValueError(\"If input_unit is none, the time needs to be a Fraction.\")\n        time_in_second = time\n    else:\n        if not isinstance(time, int):\n            raise ValueError(\"If you specify a input_unit, the time needs to be a int.\")\n\n        if input_unit &lt; 0:\n            raise ValueError(\"The input_unit needs to be above or equal to 0.\")\n\n        time_in_second = time * Fraction(1, 10 ** input_unit)\n\n    first_timestamps = self.frame_to_time(0, TimeType.EXACT)\n\n    if time_in_second &lt; first_timestamps and time_type == TimeType.EXACT:\n        raise ValueError(f\"You cannot specify a time under the first timestamps {first_timestamps} with the TimeType.EXACT.\")\n    if time_in_second &lt;= first_timestamps:\n        if time_type == TimeType.START:\n            return 0\n        elif time_type == TimeType.END:\n            raise ValueError(f\"You cannot specify a time under or equals the first timestamps {first_timestamps} with the TimeType.END.\")\n\n    frame = self._time_to_frame(time_in_second, time_type)\n    return frame\n</code></pre>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.frame_to_time","title":"<code>frame_to_time(frame, time_type, output_unit=None, center_time=False)</code>","text":"<pre><code>frame_to_time(\n    frame: int,\n    time_type: TimeType,\n    output_unit: None = None,\n    center_time: bool = False,\n) -&gt; Fraction\n</code></pre><pre><code>frame_to_time(\n    frame: int,\n    time_type: TimeType,\n    output_unit: int,\n    center_time: bool = False,\n) -&gt; int\n</code></pre> <p>Converts a given frame number into the corresponding time value based on the specified time type.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The frame number to convert.</p> required <code>time_type</code> <code>TimeType</code> <p>The type of timing to use for conversion.</p> required <code>output_unit</code> <code>int | None</code> <p>The unit of the output time value. Must be a non-negative integer if specified.</p> <p>Common values:</p> <ul> <li>3 means milliseconds</li> <li>6 means microseconds</li> <li>9 means nanoseconds</li> </ul> <p>If None, the output will be a Fraction representing seconds.</p> <code>None</code> <code>center_time</code> <code>bool</code> <p>If True, the output time will represent the time at the center of two frames. This option is only applicable when <code>time_type</code> is either <code>TimeType.START</code> or <code>TimeType.END</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>int | Fraction</code> <p>The corresponding time for the given frame number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START, 3)\n83\n&gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START)\n7507/90000\n&gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START, 3, True)\n63\n# Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n</code></pre> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>def frame_to_time(\n    self,\n    frame: int,\n    time_type: TimeType,\n    output_unit: int | None = None,\n    center_time: bool = False,\n) -&gt; int | Fraction:\n    \"\"\"Converts a given frame number into the corresponding time value based on the specified time type.\n\n    Parameters:\n        frame: The frame number to convert.\n        time_type: The type of timing to use for conversion.\n        output_unit: The unit of the output time value.\n            Must be a non-negative integer if specified.\n\n            Common values:\n\n            - 3 means milliseconds\n            - 6 means microseconds\n            - 9 means nanoseconds\n\n            If None, the output will be a Fraction representing seconds.\n        center_time: If True, the output time will represent the time at the center of two frames.\n            This option is only applicable when `time_type` is either [`TimeType.START`][video_timestamps.time_type.TimeType.START] or [`TimeType.END`][video_timestamps.time_type.TimeType.END].\n\n    Returns:\n        The corresponding time for the given frame number.\n\n    Examples:\n        &gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START, 3)\n        83\n        &gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START)\n        7507/90000\n        &gt;&gt;&gt; timestamps.frame_to_time(2, TimeType.START, 3, True)\n        63\n        # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n    \"\"\"\n\n    if output_unit is not None and output_unit &lt; 0:\n        raise ValueError(\"The output_unit needs to be above or equal to 0.\")\n\n    if frame &lt; 0:\n        raise ValueError(\"You cannot specify a frame under 0.\")\n\n    if time_type == TimeType.EXACT and center_time:\n        raise ValueError(\"It doesn't make sense to use the time in the center of two frame for TimeType.EXACT.\")\n\n    if time_type == TimeType.START:\n        upper_bound = self._frame_to_time(frame)\n\n        if center_time and frame &gt; 0:\n            lower_bound = self._frame_to_time(frame - 1)\n            time = (lower_bound + upper_bound) / 2\n        else:\n            time = upper_bound\n    elif time_type == TimeType.END:\n        upper_bound = self._frame_to_time(frame + 1)\n\n        if center_time:\n            lower_bound = self._frame_to_time(frame)\n            time = (lower_bound + upper_bound) / 2\n        else:\n            time = upper_bound\n    elif time_type == TimeType.EXACT:\n        time = self._frame_to_time(frame)\n    else:\n        raise ValueError(f'The TimeType \"{time_type}\" isn\\'t supported.')\n\n    if output_unit is None:\n        return time\n\n    if time_type == TimeType.EXACT:\n        time_output = ceil(time * Fraction(10) ** output_unit)\n    elif center_time and not (time_type == TimeType.START and frame == 0):\n        time_output = RoundingMethod.ROUND(time * 10 ** output_unit)\n    else:\n        time_output = floor(time * Fraction(10) ** output_unit)\n\n    result_frame = self.time_to_frame(time_output, time_type, output_unit)\n\n    if frame != result_frame:\n        raise ValueError(\n            f\"The frame {frame} cannot be represented exactly at output_unit={output_unit}. \"\n            f\"The conversion gave the time {time_output} which correspond to the frame {result_frame} which is different then {frame}. \"\n            f\"Try using a finer output_unit then {time_output}.\"\n        )\n\n    return time_output\n</code></pre>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.pts_to_frame","title":"<code>pts_to_frame(pts, time_type, time_scale=None)</code>","text":"<p>Converts a given PTS into the corresponding frame number based on the specified time type.</p> <p>Parameters:</p> Name Type Description Default <code>pts</code> <code>int</code> <p>The Presentation Time Stamp value to convert.</p> required <code>time_type</code> <code>TimeType</code> <p>The type of timing to use for conversion.</p> required <code>time_scale</code> <code>Fraction | None</code> <p>The time scale to interpret the <code>pts</code> parameter. If None, it is assumed that the <code>pts</code> parameter uses the same time scale as the Timestamps object.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The corresponding frame number for the given PTS.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timestamps.pts_to_frame(7507, TimeType.START, Fraction(90000))\n2\n# Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n</code></pre> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>def pts_to_frame(\n    self,\n    pts: int,\n    time_type: TimeType,\n    time_scale: Fraction | None = None\n) -&gt; int:\n    \"\"\"Converts a given PTS into the corresponding frame number based on the specified time type.\n\n    Parameters:\n        pts: The Presentation Time Stamp value to convert.\n        time_type: The type of timing to use for conversion.\n        time_scale: The time scale to interpret the `pts` parameter.\n            If None, it is assumed that the `pts` parameter uses the same time scale as the Timestamps object.\n\n    Returns:\n        The corresponding frame number for the given PTS.\n\n    Examples:\n        &gt;&gt;&gt; timestamps.pts_to_frame(7507, TimeType.START, Fraction(90000))\n        2\n        # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n    \"\"\"\n\n    if time_scale is None:\n        time = pts / self.time_scale\n    else:\n        time = pts / time_scale\n\n    frame = self.time_to_frame(time, time_type)\n    return frame\n</code></pre>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.frame_to_pts","title":"<code>frame_to_pts(frame, time_type, time_scale=None)</code>","text":"<p>Converts a given frame number into the corresponding PTS based on the specified time type.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The frame number to convert.</p> required <code>time_type</code> <code>TimeType</code> <p>The type of timing to use for conversion.</p> required <code>time_scale</code> <code>Fraction | None</code> <p>The time scale to interpret the <code>pts</code> parameter. If None, it is assumed that the <code>pts</code> parameter uses the same time scale as the Timestamps object.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The corresponding PTS for the given frame number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timestamps.frame_to_pts(2, TimeType.START, Fraction(90000))\n7507\n# Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n</code></pre> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>def frame_to_pts(\n    self,\n    frame: int,\n    time_type: TimeType,\n    time_scale: Fraction | None = None\n) -&gt; int:\n    \"\"\"Converts a given frame number into the corresponding PTS based on the specified time type.\n\n    Parameters:\n        frame: The frame number to convert.\n        time_type: The type of timing to use for conversion.\n        time_scale: The time scale to interpret the `pts` parameter.\n            If None, it is assumed that the `pts` parameter uses the same time scale as the Timestamps object.\n\n    Returns:\n        The corresponding PTS for the given frame number.\n\n    Examples:\n        &gt;&gt;&gt; timestamps.frame_to_pts(2, TimeType.START, Fraction(90000))\n        7507\n        # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n    \"\"\"\n\n    time = self.frame_to_time(frame, time_type)\n\n    round_pts_method: Callable[[Fraction], int]\n    if time_type == TimeType.EXACT:\n        round_pts_method = ceil\n    else:\n        round_pts_method = floor\n\n    if time_scale is None:\n        pts = time * self.time_scale\n        if pts != round_pts_method(pts):\n            raise ValueError(f\"An unexpected error occured. The generated pts {pts} isn't an integer. The requested frame is {frame} and the requested time_type is {time_type}. The object is {repr(self)}. Please, open an issue on GitHub.\")\n    else:\n        pts = time * time_scale\n\n    return round_pts_method(pts)\n</code></pre>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.move_time_to_frame","title":"<code>move_time_to_frame(time, time_type, output_unit=None, input_unit=None, center_time=False)</code>","text":"<pre><code>move_time_to_frame(\n    time: int | Fraction,\n    time_type: TimeType,\n    output_unit: None,\n    input_unit: int | None = None,\n    center_time: bool = False,\n) -&gt; Fraction\n</code></pre><pre><code>move_time_to_frame(\n    time: int | Fraction,\n    time_type: TimeType,\n    output_unit: int,\n    input_unit: int | None = None,\n    center_time: bool = False,\n) -&gt; int\n</code></pre> <p>Moves the time to the corresponding frame time. It is something close to using \"CTRL + 3\" and \"CTRL + 4\" on Aegisub.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int | Fraction</code> <p>The time value to convert.</p> <ul> <li> <p>If <code>time</code> is an int, the unit of the value is specified by <code>input_unit</code> parameter.</p> </li> <li> <p>If <code>time</code> is a Fraction, the value is expected to be in seconds.</p> </li> </ul> required <code>time_type</code> <code>TimeType</code> <p>The type of timing to use for conversion.</p> required <code>output_unit</code> <code>int | None</code> <p>The unit of the output time value. Must be a non-negative integer if specified.</p> <p>Common values:</p> <ul> <li>3 means milliseconds</li> <li>6 means microseconds</li> <li>9 means nanoseconds</li> </ul> <p>If None, the output will be a Fraction representing seconds.</p> <code>None</code> <code>input_unit</code> <code>int | None</code> <p>The unit of the <code>time</code> parameter when it is an int. Must be a non-negative integer if specified.</p> <p>Common values:</p> <ul> <li>3 means milliseconds</li> <li>6 means microseconds</li> <li>9 means nanoseconds</li> </ul> <p>If None, the <code>time</code> will be a Fraction representing seconds.</p> <code>None</code> <code>center_time</code> <code>bool</code> <p>If True, the output time will represent the time at the center of two frames. This option is only applicable when <code>time_type</code> is either <code>TimeType.START</code> or <code>TimeType.END</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>int | Fraction</code> <p>The output represents <code>time</code> moved to the frame time.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timestamps.move_time_to_frame(50, TimeType.START, 3, 3)\n83\n&gt;&gt;&gt; timestamps.move_time_to_frame(50, TimeType.START, 9, 3)\n83411111\n# Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n</code></pre> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>def move_time_to_frame(\n    self,\n    time: int | Fraction,\n    time_type: TimeType,\n    output_unit: int | None = None,\n    input_unit: int | None = None,\n    center_time: bool = False\n) -&gt; int | Fraction:\n    \"\"\"\n    Moves the time to the corresponding frame time.\n    It is something close to using \"CTRL + 3\" and \"CTRL + 4\" on Aegisub.\n\n    Parameters:\n        time: The time value to convert.\n\n            - If `time` is an int, the unit of the value is specified by `input_unit` parameter.\n\n            - If `time` is a Fraction, the value is expected to be in seconds.\n        time_type: The type of timing to use for conversion.\n        output_unit: The unit of the output time value.\n            Must be a non-negative integer if specified.\n\n            Common values:\n\n            - 3 means milliseconds\n            - 6 means microseconds\n            - 9 means nanoseconds\n\n            If None, the output will be a Fraction representing seconds.\n        input_unit: The unit of the `time` parameter when it is an int.\n            Must be a non-negative integer if specified.\n\n            Common values:\n\n            - 3 means milliseconds\n            - 6 means microseconds\n            - 9 means nanoseconds\n\n            If None, the `time` will be a Fraction representing seconds.\n        center_time: If True, the output time will represent the time at the center of two frames.\n            This option is only applicable when `time_type` is either [`TimeType.START`][video_timestamps.time_type.TimeType.START] or [`TimeType.END`][video_timestamps.time_type.TimeType.END].\n\n    Returns:\n        The output represents `time` moved to the frame time.\n\n    Examples:\n        &gt;&gt;&gt; timestamps.move_time_to_frame(50, TimeType.START, 3, 3)\n        83\n        &gt;&gt;&gt; timestamps.move_time_to_frame(50, TimeType.START, 9, 3)\n        83411111\n        # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n    \"\"\"\n\n    return self.frame_to_time(self.time_to_frame(time, time_type, input_unit), time_type, output_unit, center_time)\n</code></pre>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.pts_to_time","title":"<code>pts_to_time(pts, time_type, output_unit, time_scale=None)</code>","text":"<p>Converts a given PTS into the corresponding time, ensuring that the resulting value corresponds to the same frame.</p> <p>Parameters:</p> Name Type Description Default <code>pts</code> <code>int</code> <p>The Presentation Time Stamp value to convert.</p> required <code>time_type</code> <code>TimeType</code> <p>The type of timing to use for conversion.</p> required <code>time_scale</code> <code>Fraction | None</code> <p>The time scale to interpret the <code>pts</code> parameter. If None, it is assumed that the <code>pts</code> parameter uses the same time scale as the Timestamps object.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The corresponding time for the given PTS.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timestamps.pts_to_time(7507, TimeType.START, 3, Fraction(90000))\n83\n&gt;&gt;&gt; timestamps.pts_to_time(7507, TimeType.START, 9, Fraction(90000))\n83411111\n# Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n</code></pre> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>def pts_to_time(\n    self,\n    pts: int,\n    time_type: TimeType,\n    output_unit: int,\n    time_scale: Fraction | None = None\n) -&gt; int:\n    \"\"\"\n    Converts a given PTS into the corresponding time, ensuring that\n    the resulting value corresponds to the same frame.\n\n    Parameters:\n        pts: The Presentation Time Stamp value to convert.\n        time_type: The type of timing to use for conversion.\n        time_scale: The time scale to interpret the `pts` parameter.\n            If None, it is assumed that the `pts` parameter uses the same time scale as the Timestamps object.\n\n    Returns:\n        The corresponding time for the given PTS.\n\n    Examples:\n        &gt;&gt;&gt; timestamps.pts_to_time(7507, TimeType.START, 3, Fraction(90000))\n        83\n        &gt;&gt;&gt; timestamps.pts_to_time(7507, TimeType.START, 9, Fraction(90000))\n        83411111\n        # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n    \"\"\"\n\n    if time_scale is None:\n        time = pts / self.time_scale\n    else:\n        time = pts / time_scale\n\n    return self.time_to_time(time, time_type, output_unit)\n</code></pre>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.time_to_pts","title":"<code>time_to_pts(time, time_type, input_unit=None, time_scale=None)</code>","text":"<pre><code>time_to_pts(\n    time: int,\n    time_type: TimeType,\n    input_unit: int,\n    time_scale: Fraction | None = None,\n) -&gt; int\n</code></pre><pre><code>time_to_pts(\n    time: Fraction,\n    time_type: TimeType,\n    input_unit: None = None,\n    time_scale: Fraction | None = None,\n) -&gt; int\n</code></pre> <p>Converts a given time value into the corresponding PTS, ensuring that the resulting value corresponds to the same frame.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int | Fraction</code> <p>The time value to convert.</p> <ul> <li> <p>If <code>time</code> is an int, the unit of the value is specified by <code>input_unit</code> parameter.</p> </li> <li> <p>If <code>time</code> is a Fraction, the value is expected to be in seconds.</p> </li> </ul> required <code>time_type</code> <code>TimeType</code> <p>The type of timing to use for conversion.</p> required <code>input_unit</code> <code>int | None</code> <p>The unit of the <code>time</code> parameter when it is an int. Must be a non-negative integer if specified.</p> <p>Common values:</p> <ul> <li>3 means milliseconds</li> <li>6 means microseconds</li> <li>9 means nanoseconds</li> </ul> <p>If None, the <code>time</code> will be a <code>Fraction</code> representing seconds.</p> <code>None</code> <code>time_scale</code> <code>Fraction | None</code> <p>The time scale to interpret the <code>pts</code> that will be returned by this function. - If None, the <code>pts</code> that will be returned will uses the same time scale as the Timestamps object.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The corresponding PTS for the given time.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timestamps.time_to_pts(83, TimeType.START, 3, Fraction(90000))\n7470\n&gt;&gt;&gt; timestamps.time_to_pts(83411111, TimeType.START, 9, Fraction(90000))\n7507\n# Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n</code></pre> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>def time_to_pts(\n    self,\n    time: int | Fraction,\n    time_type: TimeType,\n    input_unit: int | None = None,\n    time_scale: Fraction | None = None,\n) -&gt; int:\n    \"\"\"\n    Converts a given time value into the corresponding PTS, ensuring that\n    the resulting value corresponds to the same frame.\n\n    Parameters:\n        time: The time value to convert.\n\n            - If `time` is an int, the unit of the value is specified by `input_unit` parameter.\n\n            - If `time` is a Fraction, the value is expected to be in seconds.\n        time_type: The type of timing to use for conversion.\n        input_unit: The unit of the `time` parameter when it is an int.\n            Must be a non-negative integer if specified.\n\n            Common values:\n\n            - 3 means milliseconds\n            - 6 means microseconds\n            - 9 means nanoseconds\n\n            If None, the `time` will be a `Fraction` representing seconds.\n        time_scale: The time scale to interpret the `pts` that will be returned by this function.\n            - If None, the `pts` that will be returned will uses the same time scale as the Timestamps object.\n\n    Returns:\n        The corresponding PTS for the given time.\n\n    Examples:\n        &gt;&gt;&gt; timestamps.time_to_pts(83, TimeType.START, 3, Fraction(90000))\n        7470\n        &gt;&gt;&gt; timestamps.time_to_pts(83411111, TimeType.START, 9, Fraction(90000))\n        7507\n        # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n    \"\"\"\n\n    if input_unit is None:\n        time_in_second = time\n    else:\n        time_in_second = time * Fraction(1, 10 ** input_unit)\n\n    if time_scale is None:\n        output_time_scale = self.time_scale\n    else:\n        output_time_scale = time_scale\n\n    frame = self.time_to_frame(time, time_type, input_unit)\n    pts_output = time_in_second * output_time_scale\n\n    # Try with round first because we want to get the closest result\n    pts_output_round = RoundingMethod.ROUND(pts_output)\n    frame_round = self.pts_to_frame(pts_output_round, time_type, output_time_scale)\n    if frame_round == frame:\n        return pts_output_round\n\n    # Try with the opposite of round\n    pts_output_other = floor(pts_output) if pts_output_round == ceil(pts_output) else ceil(pts_output)\n    frame_other = self.pts_to_frame(pts_output_other, time_type, output_time_scale)\n    if frame_other == frame:\n        return pts_output_other\n\n    raise ValueError(f\"It is not possible to convert the time {time_in_second} to a PTS with a timescale of {output_time_scale} accurately.\")\n</code></pre>"},{"location":"reference/abc_timestamps/#video_timestamps.abc_timestamps.ABCTimestamps.time_to_time","title":"<code>time_to_time(time, time_type, output_unit, input_unit=None)</code>","text":"<pre><code>time_to_time(\n    time: int,\n    time_type: TimeType,\n    output_unit: int,\n    input_unit: int,\n) -&gt; int\n</code></pre><pre><code>time_to_time(\n    time: Fraction,\n    time_type: TimeType,\n    output_unit: int,\n    input_unit: None = None,\n) -&gt; int\n</code></pre> <p>Converts a given time value from one unit to another, ensuring that the resulting value corresponds to the same frame.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int | Fraction</code> <p>The time value to convert.</p> <ul> <li> <p>If <code>time</code> is an int, the unit of the value is specified by <code>input_unit</code> parameter.</p> </li> <li> <p>If <code>time</code> is a Fraction, the value is expected to be in seconds.</p> </li> </ul> required <code>time_type</code> <code>TimeType</code> <p>The type of timing to use for conversion.</p> required <code>output_unit</code> <code>int</code> <p>The unit of the output time value. Must be a non-negative integer.</p> <p>Common values:</p> <ul> <li>3 means milliseconds</li> <li>6 means microseconds</li> <li>9 means nanoseconds</li> </ul> required <code>input_unit</code> <code>int | None</code> <p>The unit of the <code>time</code> parameter when it is an <code>int</code>. - Must be a non-negative integer if specified.</p> <p>Common values:</p> <ul> <li>3 means milliseconds</li> <li>6 means microseconds</li> <li>9 means nanoseconds</li> </ul> <p>If None, the <code>time</code> will be a <code>Fraction</code> representing seconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The converted time value expressed in <code>output_unit</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; timestamps.time_to_time(83411111, TimeType.START, 3, 9)\n83\n&gt;&gt;&gt; timestamps.time_to_time(83411112, TimeType.START, 3, 9)\n84\n# Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n</code></pre> Source code in <code>video_timestamps/abc_timestamps.py</code> <pre><code>def time_to_time(\n    self,\n    time: int | Fraction,\n    time_type: TimeType,\n    output_unit: int,\n    input_unit: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Converts a given time value from one unit to another, ensuring that\n    the resulting value corresponds to the same frame.\n\n    Parameters:\n        time: The time value to convert.\n\n            - If `time` is an int, the unit of the value is specified by `input_unit` parameter.\n\n            - If `time` is a Fraction, the value is expected to be in seconds.\n        time_type: The type of timing to use for conversion.\n        output_unit: The unit of the output time value.\n            Must be a non-negative integer.\n\n            Common values:\n\n            - 3 means milliseconds\n            - 6 means microseconds\n            - 9 means nanoseconds\n        input_unit: The unit of the `time` parameter when it is an `int`.\n            - Must be a non-negative integer if specified.\n\n            Common values:\n\n            - 3 means milliseconds\n            - 6 means microseconds\n            - 9 means nanoseconds\n\n            If None, the `time` will be a `Fraction` representing seconds.\n\n    Returns:\n        The converted time value expressed in `output_unit`.\n\n    Examples:\n        &gt;&gt;&gt; timestamps.time_to_time(83411111, TimeType.START, 3, 9)\n        83\n        &gt;&gt;&gt; timestamps.time_to_time(83411112, TimeType.START, 3, 9)\n        84\n        # Example with FPS = 24000/1001, time_scale = 90000, rounding method = FLOOR.\n    \"\"\"\n    if input_unit is not None and input_unit &lt; 0:\n        raise ValueError(\"The input_unit needs to be above or equal to 0.\")\n\n    if output_unit &lt; 0:\n        raise ValueError(\"The output_unit needs to be above or equal to 0.\")\n\n    if input_unit == output_unit and isinstance(time, int): # Just to make mypy happy, use isinstance so it doesn't report int | Fraction.\n        return time\n    elif input_unit is not None and input_unit &lt; output_unit:\n        return RoundingMethod.ROUND(time * 10 ** (output_unit - input_unit)) # Just to make mypy happy, round the result, but it is impossible to get a float from this.\n    else:\n        frame = self.time_to_frame(time, time_type, input_unit)\n        if isinstance(time, int) and input_unit is not None: # Just to make mypy happy, verify if input_unit is not None even if it can't.\n            time_output = Fraction(time, 10 ** (input_unit - output_unit))\n        else:\n            time_output = time * Fraction(10 ** output_unit)\n\n        # Try with round first because we want to get the closest result\n        time_output_round = RoundingMethod.ROUND(time_output)\n        try:\n            frame_round = self.time_to_frame(time_output_round, time_type, output_unit)\n        except ValueError:\n            frame_round = None\n        if frame_round == frame:\n            return time_output_round\n\n        # Try with the opposite of round\n        time_output_other = floor(time_output) if time_output_round == ceil(time_output) else ceil(time_output)\n        try:\n            frame_other = self.time_to_frame(time_output_other, time_type, output_unit)\n        except ValueError:\n            frame_other = None\n        if frame_other == frame:\n            return time_output_other\n\n        raise ValueError(f\"It is not possible to convert the time {time} from {input_unit} to {output_unit} accurately.\")\n</code></pre>"},{"location":"reference/fps_timestamps/","title":"FPSTimestamps","text":"<p>               Bases: <code>ABCTimestamps</code></p> <p>Create a Timestamps object from a fps.</p> Source code in <code>video_timestamps/fps_timestamps.py</code> <pre><code>class FPSTimestamps(ABCTimestamps):\n    \"\"\"Create a Timestamps object from a fps.\n    \"\"\"\n\n    def __init__(\n        self,\n        rounding_method: RoundingMethod,\n        time_scale: Fraction,\n        fps: int | float | Fraction | Decimal,\n        first_timestamps: Fraction = Fraction(0)\n    ):\n        \"\"\"Initialize the FPSTimestamps object.\n\n        To understand why the `rounding_method` and the `time_scale` are needed, see the detailed explanation in the\n        [frame_to_time](../Algorithm conversion explanation.md#frame_to_time) section.\n        If after reading the [frame_to_time](../Algorithm conversion explanation.md#frame_to_time) section,\n        you still think you need to have `time = frame * (1/fps)` instead of `time = pts * timebase`, use **any** `rounding_method` and use the same value for the `time_scale` as for the `fps`.\n        It will be the equivalent.\n\n        Parameters:\n            rounding_method: The rounding method used to round/floor the PTS (Presentation Time Stamp).\n            time_scale: Unit of time (in seconds) in terms of which frame PTS are represented.\n            fps: Frames per second (must be &gt; 0).\n            first_timestamps: The first timestamp of the video. By default, 0.\n        \"\"\"\n        if time_scale &lt;= 0:\n            raise ValueError(\"Parameter ``time_scale`` must be higher than 0.\")\n\n        if fps &lt;= 0:\n            raise ValueError(\"Parameter ``fps`` must be higher than 0.\")\n\n        self.__rounding_method = rounding_method\n        self.__time_scale = time_scale\n        self.__fps = Fraction(fps)\n        self.__first_timestamps = first_timestamps\n\n    @property\n    def rounding_method(self) -&gt; RoundingMethod:\n        return self.__rounding_method\n\n    @property\n    def fps(self) -&gt; Fraction:\n        return self.__fps\n\n    @property\n    def time_scale(self) -&gt; Fraction:\n        return self.__time_scale\n\n    @property\n    def first_timestamps(self) -&gt; Fraction:\n        return self.__first_timestamps\n\n\n    def _time_to_frame(\n        self,\n        time: Fraction,\n        time_type: TimeType,\n    ) -&gt; int:\n        # To understand this, refer to docs/Algorithm conversion explanation.md\n        if time_type == TimeType.START:\n            if self.rounding_method == RoundingMethod.ROUND:\n                frame = ceil(((ceil(time * self.time_scale) - Fraction(1, 2)) / self.time_scale - self.first_timestamps) * self.fps + Fraction(1)) - 1\n            elif self.rounding_method == RoundingMethod.FLOOR:\n                frame = ceil(((ceil(time * self.time_scale)) / self.time_scale - self.first_timestamps) * self.fps + Fraction(1)) - 1\n        elif time_type == TimeType.END:\n            if self.rounding_method == RoundingMethod.ROUND:\n                frame = ceil(((ceil(time * self.time_scale) - Fraction(1, 2)) / self.time_scale - self.first_timestamps) * self.fps) - 1\n            elif self.rounding_method == RoundingMethod.FLOOR:\n                frame = ceil(((ceil(time * self.time_scale)) / self.time_scale - self.first_timestamps) * self.fps) - 1\n        elif time_type == TimeType.EXACT:\n            if self.rounding_method == RoundingMethod.ROUND:\n                frame = ceil(((floor(time * self.time_scale) + Fraction(1, 2)) / self.time_scale - self.first_timestamps) * self.fps) - 1\n            elif self.rounding_method == RoundingMethod.FLOOR:\n                frame = ceil(((floor(time * self.time_scale) + Fraction(1)) / self.time_scale - self.first_timestamps) * self.fps) - 1\n        else:\n            raise ValueError(f'The TimeType \"{time_type}\" isn\\'t supported.')\n\n        return frame\n\n\n    def _frame_to_time(\n        self,\n        frame: int,\n    ) -&gt; Fraction:\n        # To understand this, refer to docs/Algorithm conversion explanation.md\n        return self.rounding_method((frame/self.fps + self.first_timestamps) * self.time_scale) / self.time_scale\n\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, FPSTimestamps):\n            return False\n        return (self.rounding_method, self.fps, self.time_scale, self.first_timestamps) == (\n            other.rounding_method, other.fps, other.time_scale, other.first_timestamps\n        )\n\n\n    def __hash__(self) -&gt; int:\n        return hash(\n            (\n                self.rounding_method,\n                self.fps,\n                self.time_scale,\n                self.first_timestamps,\n            )\n        )\n</code></pre>"},{"location":"reference/fps_timestamps/#video_timestamps.fps_timestamps.FPSTimestamps.__init__","title":"<code>__init__(rounding_method, time_scale, fps, first_timestamps=Fraction(0))</code>","text":"<p>Initialize the FPSTimestamps object.</p> <p>To understand why the <code>rounding_method</code> and the <code>time_scale</code> are needed, see the detailed explanation in the frame_to_time section. If after reading the frame_to_time section, you still think you need to have <code>time = frame * (1/fps)</code> instead of <code>time = pts * timebase</code>, use any <code>rounding_method</code> and use the same value for the <code>time_scale</code> as for the <code>fps</code>. It will be the equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>rounding_method</code> <code>RoundingMethod</code> <p>The rounding method used to round/floor the PTS (Presentation Time Stamp).</p> required <code>time_scale</code> <code>Fraction</code> <p>Unit of time (in seconds) in terms of which frame PTS are represented.</p> required <code>fps</code> <code>int | float | Fraction | Decimal</code> <p>Frames per second (must be &gt; 0).</p> required <code>first_timestamps</code> <code>Fraction</code> <p>The first timestamp of the video. By default, 0.</p> <code>Fraction(0)</code> Source code in <code>video_timestamps/fps_timestamps.py</code> <pre><code>def __init__(\n    self,\n    rounding_method: RoundingMethod,\n    time_scale: Fraction,\n    fps: int | float | Fraction | Decimal,\n    first_timestamps: Fraction = Fraction(0)\n):\n    \"\"\"Initialize the FPSTimestamps object.\n\n    To understand why the `rounding_method` and the `time_scale` are needed, see the detailed explanation in the\n    [frame_to_time](../Algorithm conversion explanation.md#frame_to_time) section.\n    If after reading the [frame_to_time](../Algorithm conversion explanation.md#frame_to_time) section,\n    you still think you need to have `time = frame * (1/fps)` instead of `time = pts * timebase`, use **any** `rounding_method` and use the same value for the `time_scale` as for the `fps`.\n    It will be the equivalent.\n\n    Parameters:\n        rounding_method: The rounding method used to round/floor the PTS (Presentation Time Stamp).\n        time_scale: Unit of time (in seconds) in terms of which frame PTS are represented.\n        fps: Frames per second (must be &gt; 0).\n        first_timestamps: The first timestamp of the video. By default, 0.\n    \"\"\"\n    if time_scale &lt;= 0:\n        raise ValueError(\"Parameter ``time_scale`` must be higher than 0.\")\n\n    if fps &lt;= 0:\n        raise ValueError(\"Parameter ``fps`` must be higher than 0.\")\n\n    self.__rounding_method = rounding_method\n    self.__time_scale = time_scale\n    self.__fps = Fraction(fps)\n    self.__first_timestamps = first_timestamps\n</code></pre>"},{"location":"reference/rounding_method/","title":"RoundingMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Method used to adjust presentation timestamps (PTS).</p> Source code in <code>video_timestamps/rounding_method.py</code> <pre><code>class RoundingMethod(Enum):\n    \"\"\"Method used to adjust presentation timestamps (PTS).\n    \"\"\"\n    FLOOR = floor_method\n    \"\"\"Floor\"\"\"\n\n    ROUND = round_method\n    \"\"\"Round half up\"\"\"\n\n    def __call__(self, number: Fraction) -&gt; int:\n        method: RoundingCallType = self.value\n        return method(number)\n</code></pre>"},{"location":"reference/rounding_method/#video_timestamps.rounding_method.RoundingMethod.FLOOR","title":"<code>FLOOR = floor_method</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Floor</p>"},{"location":"reference/rounding_method/#video_timestamps.rounding_method.RoundingMethod.ROUND","title":"<code>ROUND = round_method</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Round half up</p>"},{"location":"reference/text_file_timestamps/","title":"TextFileTimestamps","text":"<p>               Bases: <code>ABCTimestamps</code></p> <p>Create a Timestamps object from a mkv timestamps file. We only support the v1, v2 and v4 format.</p> Source code in <code>video_timestamps/text_file_timestamps.py</code> <pre><code>class TextFileTimestamps(ABCTimestamps):\n    \"\"\"Create a Timestamps object from a mkv [timestamps file](https://mkvtoolnix.download/doc/mkvmerge.html#mkvmerge.external_timestamp_files).\n    We only support the v1, v2 and v4 format.\n    \"\"\"\n\n    def __init__(\n        self,\n        path_to_timestamps_file_or_content: str | Path,\n        time_scale: Fraction,\n        rounding_method: RoundingMethod,\n        normalize: bool = True,\n    ):\n        \"\"\"Initialize the TextFileTimestamps object.\n\n        The `time_scale` and `rounding_method` are required because, in reality, if you provide a timestamps file to `mkvmerge`, it can round the result.\n        For example, let's say we use this timestamps file with this command `mkvmerge --output output.mkv --timestamps 0:input_timestamps_file.txt input.mkv`\n        ```\n        # timestamp format v2\n        0\n        50.5\n        100.4\n        150.8\n        200.9\n        250\n        ```\n\n        Since mkvmerge set a default `timescale` of 1000 and use the `rounding_method` [`RoundingMethod.ROUND`][video_timestamps.rounding_method.RoundingMethod.ROUND],\n        it cannot properly represent the provided timestamps.\n        If you extract the timestamps with `mkvextract output.mkv timestamps_v2 0:final_timestamps_file.txt`, you will get this result:\n        ```\n        # timestamp format v2\n        0\n        51\n        100\n        151\n        201\n        250\n        ```\n\n        Parameters:\n            path_to_timestamps_file_or_content: If is it a Path, the path to the timestamps file.\n\n                If it is a str, a timestamps file content.\n            time_scale: Unit of time (in seconds) in terms of which frame timestamps are represented.\n\n                Important: Don't confuse time_scale with the time_base. As a reminder, time_base = 1 / time_scale.\n            rounding_method: The rounding method used to round/floor the PTS (Presentation Time Stamp).\n            normalize: If True, it will shift the PTS to make them start from 0. If false, the option does nothing.\n        \"\"\"\n\n        if isinstance(path_to_timestamps_file_or_content, Path):\n            with open(path_to_timestamps_file_or_content, encoding=\"utf-8\") as f:\n                timestamps, fps, version = TimestampsFileParser.parse_file(f)\n        else:\n            file = StringIO(path_to_timestamps_file_or_content)\n            timestamps, fps, version = TimestampsFileParser.parse_file(file)\n\n        self.__rounding_method = rounding_method\n        self.__version = version\n\n        pts_list = [self.rounding_method(Fraction(time, pow(10, 3)) * time_scale) for time in timestamps]\n\n        self._video_timestamps = VideoTimestamps(pts_list, time_scale, normalize, fps)\n\n        self._fps_timestamps = None\n        if self.version == 1:\n            assert isinstance(fps, Fraction)\n            self._fps_timestamps = FPSTimestamps(self.rounding_method, time_scale, fps, Fraction(timestamps[-1], pow(10, 3)))\n\n    @property\n    def rounding_method(self) -&gt; RoundingMethod:\n        return self.__rounding_method\n\n    @property\n    def fps(self) -&gt; Fraction:\n        if self._fps_timestamps is not None:\n            return self._fps_timestamps.fps\n        else:\n            return self._video_timestamps.fps\n\n    @property\n    def time_scale(self) -&gt; Fraction:\n        return self._video_timestamps.time_scale\n\n    @property\n    def first_timestamps(self) -&gt; Fraction:\n        return self._video_timestamps.first_timestamps\n\n    @property\n    def version(self) -&gt; int:\n        \"\"\"\n        Returns:\n            The version of the timestamps file (1, 2 or 4).\n        \"\"\"\n        return self.__version\n\n    @property\n    def nbr_frames(self) -&gt; int:\n        \"\"\"\n        Returns:\n            The number of frames of the timestamps file. Note that you cannot use this property with v1 timestamps file.\n        \"\"\"\n        if self.version in (2, 4):\n            return self._video_timestamps.nbr_frames\n        else:\n            raise ValueError(\"V1 timestamps file doesn't specify a number of frames.\")\n\n\n    def _time_to_frame(\n        self,\n        time: Fraction,\n        time_type: TimeType,\n    ) -&gt; int:\n        if self._fps_timestamps is not None and time &gt; self._video_timestamps.timestamps[-1]:\n            return self._video_timestamps.nbr_frames + self._fps_timestamps._time_to_frame(time, time_type)\n        else:\n            return self._video_timestamps._time_to_frame(time, time_type)\n\n\n    def _frame_to_time(\n        self,\n        frame: int,\n    ) -&gt; Fraction:\n        if self._fps_timestamps is not None and frame &gt; self._video_timestamps.nbr_frames:\n            return self._fps_timestamps._frame_to_time(frame - self._video_timestamps.nbr_frames)\n        else:\n            return self._video_timestamps._frame_to_time(frame)\n\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, TextFileTimestamps):\n            return False\n        return (self.rounding_method, self.version, self._video_timestamps, self._fps_timestamps) == (\n            other.rounding_method, other.version, other._video_timestamps, other._fps_timestamps\n        )\n\n\n    def __hash__(self) -&gt; int:\n        return hash(\n            (\n                self.rounding_method,\n                self.__version,\n                self._video_timestamps,\n                self._fps_timestamps,\n            )\n        )\n</code></pre>"},{"location":"reference/text_file_timestamps/#video_timestamps.text_file_timestamps.TextFileTimestamps.version","title":"<code>version</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The version of the timestamps file (1, 2 or 4).</p>"},{"location":"reference/text_file_timestamps/#video_timestamps.text_file_timestamps.TextFileTimestamps.nbr_frames","title":"<code>nbr_frames</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of frames of the timestamps file. Note that you cannot use this property with v1 timestamps file.</p>"},{"location":"reference/text_file_timestamps/#video_timestamps.text_file_timestamps.TextFileTimestamps.__init__","title":"<code>__init__(path_to_timestamps_file_or_content, time_scale, rounding_method, normalize=True)</code>","text":"<p>Initialize the TextFileTimestamps object.</p> <p>The <code>time_scale</code> and <code>rounding_method</code> are required because, in reality, if you provide a timestamps file to <code>mkvmerge</code>, it can round the result. For example, let's say we use this timestamps file with this command <code>mkvmerge --output output.mkv --timestamps 0:input_timestamps_file.txt input.mkv</code> <pre><code># timestamp format v2\n0\n50.5\n100.4\n150.8\n200.9\n250\n</code></pre></p> <p>Since mkvmerge set a default <code>timescale</code> of 1000 and use the <code>rounding_method</code> <code>RoundingMethod.ROUND</code>, it cannot properly represent the provided timestamps. If you extract the timestamps with <code>mkvextract output.mkv timestamps_v2 0:final_timestamps_file.txt</code>, you will get this result: <pre><code># timestamp format v2\n0\n51\n100\n151\n201\n250\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>path_to_timestamps_file_or_content</code> <code>str | Path</code> <p>If is it a Path, the path to the timestamps file.</p> <p>If it is a str, a timestamps file content.</p> required <code>time_scale</code> <code>Fraction</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.</p> <p>Important: Don't confuse time_scale with the time_base. As a reminder, time_base = 1 / time_scale.</p> required <code>rounding_method</code> <code>RoundingMethod</code> <p>The rounding method used to round/floor the PTS (Presentation Time Stamp).</p> required <code>normalize</code> <code>bool</code> <p>If True, it will shift the PTS to make them start from 0. If false, the option does nothing.</p> <code>True</code> Source code in <code>video_timestamps/text_file_timestamps.py</code> <pre><code>def __init__(\n    self,\n    path_to_timestamps_file_or_content: str | Path,\n    time_scale: Fraction,\n    rounding_method: RoundingMethod,\n    normalize: bool = True,\n):\n    \"\"\"Initialize the TextFileTimestamps object.\n\n    The `time_scale` and `rounding_method` are required because, in reality, if you provide a timestamps file to `mkvmerge`, it can round the result.\n    For example, let's say we use this timestamps file with this command `mkvmerge --output output.mkv --timestamps 0:input_timestamps_file.txt input.mkv`\n    ```\n    # timestamp format v2\n    0\n    50.5\n    100.4\n    150.8\n    200.9\n    250\n    ```\n\n    Since mkvmerge set a default `timescale` of 1000 and use the `rounding_method` [`RoundingMethod.ROUND`][video_timestamps.rounding_method.RoundingMethod.ROUND],\n    it cannot properly represent the provided timestamps.\n    If you extract the timestamps with `mkvextract output.mkv timestamps_v2 0:final_timestamps_file.txt`, you will get this result:\n    ```\n    # timestamp format v2\n    0\n    51\n    100\n    151\n    201\n    250\n    ```\n\n    Parameters:\n        path_to_timestamps_file_or_content: If is it a Path, the path to the timestamps file.\n\n            If it is a str, a timestamps file content.\n        time_scale: Unit of time (in seconds) in terms of which frame timestamps are represented.\n\n            Important: Don't confuse time_scale with the time_base. As a reminder, time_base = 1 / time_scale.\n        rounding_method: The rounding method used to round/floor the PTS (Presentation Time Stamp).\n        normalize: If True, it will shift the PTS to make them start from 0. If false, the option does nothing.\n    \"\"\"\n\n    if isinstance(path_to_timestamps_file_or_content, Path):\n        with open(path_to_timestamps_file_or_content, encoding=\"utf-8\") as f:\n            timestamps, fps, version = TimestampsFileParser.parse_file(f)\n    else:\n        file = StringIO(path_to_timestamps_file_or_content)\n        timestamps, fps, version = TimestampsFileParser.parse_file(file)\n\n    self.__rounding_method = rounding_method\n    self.__version = version\n\n    pts_list = [self.rounding_method(Fraction(time, pow(10, 3)) * time_scale) for time in timestamps]\n\n    self._video_timestamps = VideoTimestamps(pts_list, time_scale, normalize, fps)\n\n    self._fps_timestamps = None\n    if self.version == 1:\n        assert isinstance(fps, Fraction)\n        self._fps_timestamps = FPSTimestamps(self.rounding_method, time_scale, fps, Fraction(timestamps[-1], pow(10, 3)))\n</code></pre>"},{"location":"reference/time_type/","title":"TimeType","text":"<p>               Bases: <code>Enum</code></p> <p>Represents different types of time intervals for video frames in a player.</p> <p>When working with a video that has a frame rate of 24000/1001 fps, using the <code>RoundingMethod.ROUND</code> and with the timescale 1000, the first 4 frames will start at the following times in a video player:</p> <ul> <li>Frame 0: 0 ms</li> <li>Frame 1: 42 ms</li> <li>Frame 2: 83 ms</li> <li>Frame 3: 125 ms</li> </ul> Source code in <code>video_timestamps/time_type.py</code> <pre><code>class TimeType(Enum):\n    \"\"\"\n    Represents different types of time intervals for video frames in a player.\n\n    When working with a video that has a frame rate of 24000/1001 fps, using the [`RoundingMethod.ROUND`][video_timestamps.rounding_method.RoundingMethod.ROUND] and with the timescale 1000,\n    the first 4 frames will start at the following times in a video player:\n\n    - Frame 0: 0 ms\n    - Frame 1: 42 ms\n    - Frame 2: 83 ms\n    - Frame 3: 125 ms\n    \"\"\"\n\n    START = \"START\"\n    \"\"\"\n    Corresponds to the start time of the subtitle.\n    Each frame has an interval: ]Previous_frame_time, Current_frame_time]\n\n    Example:\n        - fps = 24000/1001\n        - rounding_method = [`RoundingMethod.ROUND`][video_timestamps.rounding_method.RoundingMethod.ROUND]\n        - time_scale = 1000\n\n        Frame intervals:\n\n        - Frame 0: 0 ms\n        - Frame 1: ]0, 42] ms\n        - Frame 2: ]42, 83] ms\n    \"\"\"\n\n    END = \"END\"\n    \"\"\"\n    Corresponds to the end time of the subtitle.\n    Each frame has an interval: ]Current_frame_time, Next_frame_time]\n\n    Example:\n        - fps = 24000/1001\n        - rounding_method = [`RoundingMethod.ROUND`][video_timestamps.rounding_method.RoundingMethod.ROUND]\n        - time_scale = 1000\n\n        Frame intervals:\n\n        - Frame 0: ]0, 42] ms\n        - Frame 1: ]42, 83] ms\n        - Frame 2: ]83, 125] ms\n    \"\"\"\n\n    EXACT = \"EXACT\"\n    \"\"\"\n    Corresponds to the precise frame time in the video player.\n    Each frame has an interval: [Current_frame_time, Next_frame_time[\n\n    Example:\n        - fps = 24000/1001\n        - rounding_method = [`RoundingMethod.ROUND`][video_timestamps.rounding_method.RoundingMethod.ROUND]\n        - time_scale = 1000\n\n        Frame intervals:\n\n        - Frame 0: [0, 42[ ms\n        - Frame 1: [42, 83[ ms\n        - Frame 2: [83, 125[ ms\n    \"\"\"\n</code></pre>"},{"location":"reference/time_type/#video_timestamps.time_type.TimeType.START","title":"<code>START = 'START'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Corresponds to the start time of the subtitle. Each frame has an interval: ]Previous_frame_time, Current_frame_time]</p> Example <ul> <li>fps = 24000/1001</li> <li>rounding_method = <code>RoundingMethod.ROUND</code></li> <li>time_scale = 1000</li> </ul> <p>Frame intervals:</p> <ul> <li>Frame 0: 0 ms</li> <li>Frame 1: ]0, 42] ms</li> <li>Frame 2: ]42, 83] ms</li> </ul>"},{"location":"reference/time_type/#video_timestamps.time_type.TimeType.END","title":"<code>END = 'END'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Corresponds to the end time of the subtitle. Each frame has an interval: ]Current_frame_time, Next_frame_time]</p> Example <ul> <li>fps = 24000/1001</li> <li>rounding_method = <code>RoundingMethod.ROUND</code></li> <li>time_scale = 1000</li> </ul> <p>Frame intervals:</p> <ul> <li>Frame 0: ]0, 42] ms</li> <li>Frame 1: ]42, 83] ms</li> <li>Frame 2: ]83, 125] ms</li> </ul>"},{"location":"reference/time_type/#video_timestamps.time_type.TimeType.EXACT","title":"<code>EXACT = 'EXACT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Corresponds to the precise frame time in the video player. Each frame has an interval: [Current_frame_time, Next_frame_time[</p> Example <ul> <li>fps = 24000/1001</li> <li>rounding_method = <code>RoundingMethod.ROUND</code></li> <li>time_scale = 1000</li> </ul> <p>Frame intervals:</p> <ul> <li>Frame 0: [0, 42[ ms</li> <li>Frame 1: [42, 83[ ms</li> <li>Frame 2: [83, 125[ ms</li> </ul>"},{"location":"reference/time_unit_converter/","title":"TimeUnitConverter","text":"<p>Utility class for converting between time units.</p> Source code in <code>video_timestamps/time_unit_converter.py</code> <pre><code>class TimeUnitConverter:\n    \"\"\"Utility class for converting between time units.\"\"\"\n\n    @staticmethod\n    def time_base_to_time_scale(time_base: Fraction) -&gt; Fraction:\n        \"\"\"\n        Convert a time base to a time scale.\n\n        Parameters:\n            time_base: The time base to convert.\n\n        Returns:\n            The corresponding time scale.\n        \"\"\"\n        return 1 / time_base\n\n\n    @staticmethod\n    def time_scale_to_time_base(time_scale: Fraction) -&gt; Fraction:\n        \"\"\"\n        Convert a time scale to a time base.\n\n        Parameters:\n            time_scale: The time scale to convert.\n\n        Returns:\n            The corresponding time base.\n        \"\"\"\n        return 1 / time_scale\n\n\n    @staticmethod\n    def timestamp_scale_to_time_scale(timestamp_scale: int) -&gt; Fraction:\n        \"\"\"\n        Convert a timestamp scale to a time scale.\n\n        Parameters:\n            timestamp_scale: The timestamp scale (e.g., nanoseconds per tick).\n\n        Returns:\n            The corresponding time scale.\n        \"\"\"\n        return Fraction(pow(10, 9), timestamp_scale)\n\n\n    @staticmethod\n    def time_scale_to_timestamp_scale(time_scale: Fraction) -&gt; int:\n        \"\"\"\n        Convert a time scale to a timestamp scale.\n\n        Parameters:\n            time_scale: The time scale to convert.\n\n        Returns:\n            The corresponding timestamp scale.\n        \"\"\"\n        timestamp_scale = Fraction(pow(10, 9), time_scale)\n\n        if sys.version_info &gt;= (3, 12):\n            is_integer = timestamp_scale.is_integer()\n        else:\n            is_integer = timestamp_scale.denominator == 1\n\n        if not is_integer:\n            raise ValueError(f\"The timescale {time_scale} cannot be converted to a timestamp scale because the result {timestamp_scale} isn't a integer.\")\n\n        return int(timestamp_scale)\n\n\n    @staticmethod\n    def timestamp_scale_to_time_base(timestamp_scale: int) -&gt; Fraction:\n        \"\"\"\n        Convert a timestamp scale to a time base.\n\n        Parameters:\n            timestamp_scale: The timestamp scale.\n\n        Returns:\n            The corresponding time base.\n        \"\"\"\n        return Fraction(timestamp_scale, pow(10, 9))\n\n\n    @staticmethod\n    def time_base_to_timestamp_scale(time_base: Fraction) -&gt; int:\n        \"\"\"\n        Convert a time base to a timestamp scale.\n\n        Parameters:\n            time_base: The time base to convert.\n\n        Returns:\n            The corresponding timestamp scale.\n        \"\"\"\n        timestamp_scale = time_base * pow(10, 9)\n\n        if sys.version_info &gt;= (3, 12):\n            is_integer = timestamp_scale.is_integer()\n        else:\n            is_integer = timestamp_scale.denominator == 1\n\n        if not is_integer:\n            raise ValueError(f\"The timebase {time_base} cannot be converted to a timestamp scale because the result {timestamp_scale} isn't a integer.\")\n\n        return int(timestamp_scale)\n</code></pre>"},{"location":"reference/time_unit_converter/#video_timestamps.time_unit_converter.TimeUnitConverter.time_base_to_time_scale","title":"<code>time_base_to_time_scale(time_base)</code>  <code>staticmethod</code>","text":"<p>Convert a time base to a time scale.</p> <p>Parameters:</p> Name Type Description Default <code>time_base</code> <code>Fraction</code> <p>The time base to convert.</p> required <p>Returns:</p> Type Description <code>Fraction</code> <p>The corresponding time scale.</p> Source code in <code>video_timestamps/time_unit_converter.py</code> <pre><code>@staticmethod\ndef time_base_to_time_scale(time_base: Fraction) -&gt; Fraction:\n    \"\"\"\n    Convert a time base to a time scale.\n\n    Parameters:\n        time_base: The time base to convert.\n\n    Returns:\n        The corresponding time scale.\n    \"\"\"\n    return 1 / time_base\n</code></pre>"},{"location":"reference/time_unit_converter/#video_timestamps.time_unit_converter.TimeUnitConverter.time_scale_to_time_base","title":"<code>time_scale_to_time_base(time_scale)</code>  <code>staticmethod</code>","text":"<p>Convert a time scale to a time base.</p> <p>Parameters:</p> Name Type Description Default <code>time_scale</code> <code>Fraction</code> <p>The time scale to convert.</p> required <p>Returns:</p> Type Description <code>Fraction</code> <p>The corresponding time base.</p> Source code in <code>video_timestamps/time_unit_converter.py</code> <pre><code>@staticmethod\ndef time_scale_to_time_base(time_scale: Fraction) -&gt; Fraction:\n    \"\"\"\n    Convert a time scale to a time base.\n\n    Parameters:\n        time_scale: The time scale to convert.\n\n    Returns:\n        The corresponding time base.\n    \"\"\"\n    return 1 / time_scale\n</code></pre>"},{"location":"reference/time_unit_converter/#video_timestamps.time_unit_converter.TimeUnitConverter.timestamp_scale_to_time_scale","title":"<code>timestamp_scale_to_time_scale(timestamp_scale)</code>  <code>staticmethod</code>","text":"<p>Convert a timestamp scale to a time scale.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_scale</code> <code>int</code> <p>The timestamp scale (e.g., nanoseconds per tick).</p> required <p>Returns:</p> Type Description <code>Fraction</code> <p>The corresponding time scale.</p> Source code in <code>video_timestamps/time_unit_converter.py</code> <pre><code>@staticmethod\ndef timestamp_scale_to_time_scale(timestamp_scale: int) -&gt; Fraction:\n    \"\"\"\n    Convert a timestamp scale to a time scale.\n\n    Parameters:\n        timestamp_scale: The timestamp scale (e.g., nanoseconds per tick).\n\n    Returns:\n        The corresponding time scale.\n    \"\"\"\n    return Fraction(pow(10, 9), timestamp_scale)\n</code></pre>"},{"location":"reference/time_unit_converter/#video_timestamps.time_unit_converter.TimeUnitConverter.time_scale_to_timestamp_scale","title":"<code>time_scale_to_timestamp_scale(time_scale)</code>  <code>staticmethod</code>","text":"<p>Convert a time scale to a timestamp scale.</p> <p>Parameters:</p> Name Type Description Default <code>time_scale</code> <code>Fraction</code> <p>The time scale to convert.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The corresponding timestamp scale.</p> Source code in <code>video_timestamps/time_unit_converter.py</code> <pre><code>@staticmethod\ndef time_scale_to_timestamp_scale(time_scale: Fraction) -&gt; int:\n    \"\"\"\n    Convert a time scale to a timestamp scale.\n\n    Parameters:\n        time_scale: The time scale to convert.\n\n    Returns:\n        The corresponding timestamp scale.\n    \"\"\"\n    timestamp_scale = Fraction(pow(10, 9), time_scale)\n\n    if sys.version_info &gt;= (3, 12):\n        is_integer = timestamp_scale.is_integer()\n    else:\n        is_integer = timestamp_scale.denominator == 1\n\n    if not is_integer:\n        raise ValueError(f\"The timescale {time_scale} cannot be converted to a timestamp scale because the result {timestamp_scale} isn't a integer.\")\n\n    return int(timestamp_scale)\n</code></pre>"},{"location":"reference/time_unit_converter/#video_timestamps.time_unit_converter.TimeUnitConverter.timestamp_scale_to_time_base","title":"<code>timestamp_scale_to_time_base(timestamp_scale)</code>  <code>staticmethod</code>","text":"<p>Convert a timestamp scale to a time base.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_scale</code> <code>int</code> <p>The timestamp scale.</p> required <p>Returns:</p> Type Description <code>Fraction</code> <p>The corresponding time base.</p> Source code in <code>video_timestamps/time_unit_converter.py</code> <pre><code>@staticmethod\ndef timestamp_scale_to_time_base(timestamp_scale: int) -&gt; Fraction:\n    \"\"\"\n    Convert a timestamp scale to a time base.\n\n    Parameters:\n        timestamp_scale: The timestamp scale.\n\n    Returns:\n        The corresponding time base.\n    \"\"\"\n    return Fraction(timestamp_scale, pow(10, 9))\n</code></pre>"},{"location":"reference/time_unit_converter/#video_timestamps.time_unit_converter.TimeUnitConverter.time_base_to_timestamp_scale","title":"<code>time_base_to_timestamp_scale(time_base)</code>  <code>staticmethod</code>","text":"<p>Convert a time base to a timestamp scale.</p> <p>Parameters:</p> Name Type Description Default <code>time_base</code> <code>Fraction</code> <p>The time base to convert.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The corresponding timestamp scale.</p> Source code in <code>video_timestamps/time_unit_converter.py</code> <pre><code>@staticmethod\ndef time_base_to_timestamp_scale(time_base: Fraction) -&gt; int:\n    \"\"\"\n    Convert a time base to a timestamp scale.\n\n    Parameters:\n        time_base: The time base to convert.\n\n    Returns:\n        The corresponding timestamp scale.\n    \"\"\"\n    timestamp_scale = time_base * pow(10, 9)\n\n    if sys.version_info &gt;= (3, 12):\n        is_integer = timestamp_scale.is_integer()\n    else:\n        is_integer = timestamp_scale.denominator == 1\n\n    if not is_integer:\n        raise ValueError(f\"The timebase {time_base} cannot be converted to a timestamp scale because the result {timestamp_scale} isn't a integer.\")\n\n    return int(timestamp_scale)\n</code></pre>"},{"location":"reference/video_timestamps/","title":"VideoTimestamps","text":"<p>               Bases: <code>ABCTimestamps</code></p> <p>Create a Timestamps object from a video file.</p> Source code in <code>video_timestamps/video_timestamps.py</code> <pre><code>class VideoTimestamps(ABCTimestamps):\n    \"\"\"Create a Timestamps object from a video file.\n    \"\"\"\n\n    def __init__(\n        self,\n        pts_list: list[int],\n        time_scale: Fraction,\n        normalize: bool = True,\n        fps: Fraction | None = None,\n    ):\n        \"\"\"Initialize the VideoTimestamps object.\n\n        Parameters:\n            pts_list: A list containing the Presentation Time Stamps (PTS) for all frames.\n\n                The last pts correspond to the pts of the last frame + it's duration.\n            time_scale: Unit of time (in seconds) in terms of which frame timestamps are represented.\n\n                Important: Don't confuse time_scale with the time_base. As a reminder, time_base = 1 / time_scale.\n            normalize: If True, it will shift the PTS to make them start from 0. If false, the option does nothing.\n            fps: The frames per second of the video.\n\n                It doesn't matter if you pass this parameter because the fps isn't used.\n                It is only a parameter to avoid breaking change\n        \"\"\"\n        # Validate the PTS\n        if len(pts_list) &lt;= 1:\n            raise ValueError(\"There must be at least 2 pts.\")\n\n        if any(pts_list[i] &gt;= pts_list[i + 1] for i in range(len(pts_list) - 1)):\n            raise ValueError(\"PTS must be in non-decreasing order.\")\n\n        self.__pts_list = pts_list\n        self.__time_scale = time_scale\n\n        if normalize:\n            self.__pts_list = VideoTimestamps.normalize(self.pts_list)\n\n        self.__timestamps = [pts / self.time_scale for pts in self.pts_list]\n\n        if fps is None:\n            self.__fps = Fraction(len(pts_list) - 1, Fraction((self.pts_list[-1] - self.pts_list[0]), self.time_scale))\n        else:\n            self.__fps = fps\n\n    @classmethod\n    def from_video_file(\n        cls,\n        video_path: Path,\n        index: int = 0,\n        normalize: bool = True,\n        use_video_provider_to_guess_fps: bool = True,\n        video_provider: ABCVideoProvider = FFMS2VideoProvider()\n    ) -&gt; VideoTimestamps:\n        \"\"\"Create timestamps based on the ``video_path`` provided.\n\n        Parameters:\n            video_path: A video path.\n            index: Index of the video stream.\n            normalize: If True, it will shift the PTS to make them start from 0. If false, the option does nothing.\n            use_video_provider_to_guess_fps: If True, use the video_provider to guess the video fps.\n                If not specified, the fps will be approximate from the first and last frame PTS.\n            video_provider: The video provider to use to get the information about the video timestamps/fps.\n\n        Returns:\n            An VideoTimestamps instance representing the video file.\n        \"\"\"\n\n        if not video_path.is_file():\n            raise FileNotFoundError(f'Invalid path for the video file: \"{video_path}\"')\n\n        pts_list, time_base, fps_from_video_provider = video_provider.get_pts(str(video_path.resolve()), index)\n        time_scale = 1 / time_base\n\n        if use_video_provider_to_guess_fps:\n            fps = fps_from_video_provider\n        else:\n            fps = None\n\n        timestamps = VideoTimestamps(\n            pts_list,\n            time_scale,\n            normalize,\n            fps\n        )\n        return timestamps\n\n    @property\n    def fps(self) -&gt; Fraction:\n        return self.__fps\n\n    @property\n    def time_scale(self) -&gt; Fraction:\n        return self.__time_scale\n\n    @property\n    def first_timestamps(self) -&gt; Fraction:\n        return self.timestamps[0]\n\n    @property\n    def pts_list(self) -&gt; list[int]:\n        \"\"\"\n        Returns:\n            A list containing the Presentation Time Stamps (PTS) for all frames.\n                The last pts correspond to the pts of the last frame + it's duration.\n        \"\"\"\n        return self.__pts_list\n\n    @property\n    def timestamps(self) -&gt; list[Fraction]:\n        \"\"\"\n        Returns:\n            A list of timestamps (in seconds) corresponding to each frame, stored as `Fraction` for precision.\n        \"\"\"\n        return self.__timestamps\n\n    @property\n    def nbr_frames(self) -&gt; int:\n        \"\"\"\n        Returns:\n            Number of frames in the video.\n        \"\"\"\n        return len(self.__pts_list) - 1\n\n    @staticmethod\n    def normalize(pts_list: list[int]) -&gt; list[int]:\n        \"\"\"Shift the pts_list to make them start from 0. This way, frame 0 will start at pts 0.\n\n        Parameters:\n            pts_list: A list containing the Presentation Time Stamps (PTS) for all frames.\n\n        Returns:\n            The pts_list normalized.\n        \"\"\"\n        if pts_list[0]:\n            return list(map(lambda pts: pts - pts_list[0], pts_list))\n        return pts_list\n\n\n    def _time_to_frame(\n        self,\n        time: Fraction,\n        time_type: TimeType,\n    ) -&gt; int:\n        if time &gt; self.timestamps[-1]:\n            if time_type == TimeType.END:\n                return self.nbr_frames\n            else:\n                raise ValueError(f\"Time {time} is over the video duration. The video duration is {self.timestamps[-1]} seconds.\")\n\n        if time_type == TimeType.START:\n            return bisect_left(self.timestamps, time)\n        elif time_type == TimeType.END:\n            return bisect_left(self.timestamps, time) - 1\n        elif time_type == TimeType.EXACT:\n            return bisect_right(self.timestamps, time) - 1\n        else:\n            raise ValueError(f'The TimeType \"{time_type}\" isn\\'t supported.')\n\n\n    def _frame_to_time(\n        self,\n        frame: int,\n    ) -&gt; Fraction:\n        if frame &gt; self.nbr_frames:\n            raise ValueError(f\"The frame {frame} is over the video duration. The video contains {self.nbr_frames} frames.\")\n\n        return self.timestamps[frame]\n\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, VideoTimestamps):\n            return False\n        return (self.fps, self.time_scale, self.first_timestamps, self.pts_list, self.timestamps) == (\n            other.fps, other.time_scale, other.first_timestamps, other.pts_list, other.timestamps\n        )\n\n    @overload\n    def export_timestamps(\n        self,\n        timestamps_filename: Path,\n        *,\n        use_fraction: Literal[True],\n    ) -&gt; None:\n        ...\n\n    @overload\n    def export_timestamps(\n        self,\n        timestamps_filename: Path,\n        *,\n        precision: int,\n        precision_rounding: RoundingCallType,\n        use_fraction: Literal[False] = False,\n    ) -&gt; None:\n        ...\n\n    def export_timestamps(\n        self,\n        timestamps_filename: Path,\n        *,\n        precision: int | None = 9,\n        precision_rounding: RoundingCallType | None = RoundingMethod.ROUND,\n        use_fraction: bool = False\n    ) -&gt; None:\n        \"\"\"Export the timestamps to [timestamp format v2 file](https://mkvtoolnix.download/doc/mkvmerge.html#d4e4659).\n\n        Parameters:\n            timestamps_filename: The file path where the timestamps will be saved.\n            precision: Number of decimal places for timestamps (default: 9).\n                The minimum value is 3. Note that for mkv file, you can always use 9 (the default value).\n\n                Common values:\n\n                - 3 means milliseconds\n                - 6 means microseconds\n                - 9 means nanoseconds\n            precision_rounding: Rounding method to use for timestamps (default: round).\n\n                Examples:\n\n                - Timestamp: 453.4 ms,  precision=3, precision_rounding=RoundingMethod.ROUND --&gt; 453\n                - Timestamp: 453.4569 ms, precision=6, precision_rounding=RoundingMethod.ROUND --&gt; 453.457\n            use_fraction: The timestamps produced will be represented has a fraction (ex: \"30/2\") instead of decimal (ex: \"3.434\").\n                Note that this is not a conform to the specification.\n        \"\"\"\n        if precision is not None and precision &lt; 3:\n            raise ValueError(\"The precision needs to be at least 3 (milliseconds).\")\n\n        with localcontext() as ctx:\n            with open(timestamps_filename, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"# timestamp format v2\\n\")\n\n                for pts in self.pts_list:\n                    if use_fraction:\n                        time_ms = pts / self.time_scale * 1000\n                        f.write(f\"{time_ms}\\n\")\n                    else:\n                        assert precision is not None # Make mypy happy\n                        assert precision_rounding is not None # Make mypy happy\n\n                        time_precision = precision_rounding(pts / self.time_scale * pow(10, precision))\n                        time_ms = Fraction(time_precision, pow(10, precision - 3))\n\n                        # Be sure that decimal.Context.prec is high enough to do the conversion\n                        num_digits = len(str(time_ms.numerator // time_ms.denominator))\n                        ctx.prec = (precision - 3) + num_digits\n\n                        time_ms_d = Decimal(time_ms.numerator) / Decimal(time_ms.denominator)\n                        f.write(f\"{time_ms_d}\\n\")\n\n\n    def __hash__(self) -&gt; int:\n        return hash(\n            (\n                self.fps,\n                self.time_scale,\n                self.first_timestamps,\n                tuple(self.pts_list),\n                tuple(self.timestamps),\n            )\n        )\n</code></pre>"},{"location":"reference/video_timestamps/#video_timestamps.video_timestamps.VideoTimestamps.pts_list","title":"<code>pts_list</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[int]</code> <p>A list containing the Presentation Time Stamps (PTS) for all frames. The last pts correspond to the pts of the last frame + it's duration.</p>"},{"location":"reference/video_timestamps/#video_timestamps.video_timestamps.VideoTimestamps.timestamps","title":"<code>timestamps</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[Fraction]</code> <p>A list of timestamps (in seconds) corresponding to each frame, stored as <code>Fraction</code> for precision.</p>"},{"location":"reference/video_timestamps/#video_timestamps.video_timestamps.VideoTimestamps.nbr_frames","title":"<code>nbr_frames</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>Number of frames in the video.</p>"},{"location":"reference/video_timestamps/#video_timestamps.video_timestamps.VideoTimestamps.__init__","title":"<code>__init__(pts_list, time_scale, normalize=True, fps=None)</code>","text":"<p>Initialize the VideoTimestamps object.</p> <p>Parameters:</p> Name Type Description Default <code>pts_list</code> <code>list[int]</code> <p>A list containing the Presentation Time Stamps (PTS) for all frames.</p> <p>The last pts correspond to the pts of the last frame + it's duration.</p> required <code>time_scale</code> <code>Fraction</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.</p> <p>Important: Don't confuse time_scale with the time_base. As a reminder, time_base = 1 / time_scale.</p> required <code>normalize</code> <code>bool</code> <p>If True, it will shift the PTS to make them start from 0. If false, the option does nothing.</p> <code>True</code> <code>fps</code> <code>Fraction | None</code> <p>The frames per second of the video.</p> <p>It doesn't matter if you pass this parameter because the fps isn't used. It is only a parameter to avoid breaking change</p> <code>None</code> Source code in <code>video_timestamps/video_timestamps.py</code> <pre><code>def __init__(\n    self,\n    pts_list: list[int],\n    time_scale: Fraction,\n    normalize: bool = True,\n    fps: Fraction | None = None,\n):\n    \"\"\"Initialize the VideoTimestamps object.\n\n    Parameters:\n        pts_list: A list containing the Presentation Time Stamps (PTS) for all frames.\n\n            The last pts correspond to the pts of the last frame + it's duration.\n        time_scale: Unit of time (in seconds) in terms of which frame timestamps are represented.\n\n            Important: Don't confuse time_scale with the time_base. As a reminder, time_base = 1 / time_scale.\n        normalize: If True, it will shift the PTS to make them start from 0. If false, the option does nothing.\n        fps: The frames per second of the video.\n\n            It doesn't matter if you pass this parameter because the fps isn't used.\n            It is only a parameter to avoid breaking change\n    \"\"\"\n    # Validate the PTS\n    if len(pts_list) &lt;= 1:\n        raise ValueError(\"There must be at least 2 pts.\")\n\n    if any(pts_list[i] &gt;= pts_list[i + 1] for i in range(len(pts_list) - 1)):\n        raise ValueError(\"PTS must be in non-decreasing order.\")\n\n    self.__pts_list = pts_list\n    self.__time_scale = time_scale\n\n    if normalize:\n        self.__pts_list = VideoTimestamps.normalize(self.pts_list)\n\n    self.__timestamps = [pts / self.time_scale for pts in self.pts_list]\n\n    if fps is None:\n        self.__fps = Fraction(len(pts_list) - 1, Fraction((self.pts_list[-1] - self.pts_list[0]), self.time_scale))\n    else:\n        self.__fps = fps\n</code></pre>"},{"location":"reference/video_timestamps/#video_timestamps.video_timestamps.VideoTimestamps.from_video_file","title":"<code>from_video_file(video_path, index=0, normalize=True, use_video_provider_to_guess_fps=True, video_provider=FFMS2VideoProvider())</code>  <code>classmethod</code>","text":"<p>Create timestamps based on the <code>video_path</code> provided.</p> <p>Parameters:</p> Name Type Description Default <code>video_path</code> <code>Path</code> <p>A video path.</p> required <code>index</code> <code>int</code> <p>Index of the video stream.</p> <code>0</code> <code>normalize</code> <code>bool</code> <p>If True, it will shift the PTS to make them start from 0. If false, the option does nothing.</p> <code>True</code> <code>use_video_provider_to_guess_fps</code> <code>bool</code> <p>If True, use the video_provider to guess the video fps. If not specified, the fps will be approximate from the first and last frame PTS.</p> <code>True</code> <code>video_provider</code> <code>ABCVideoProvider</code> <p>The video provider to use to get the information about the video timestamps/fps.</p> <code>FFMS2VideoProvider()</code> <p>Returns:</p> Type Description <code>VideoTimestamps</code> <p>An VideoTimestamps instance representing the video file.</p> Source code in <code>video_timestamps/video_timestamps.py</code> <pre><code>@classmethod\ndef from_video_file(\n    cls,\n    video_path: Path,\n    index: int = 0,\n    normalize: bool = True,\n    use_video_provider_to_guess_fps: bool = True,\n    video_provider: ABCVideoProvider = FFMS2VideoProvider()\n) -&gt; VideoTimestamps:\n    \"\"\"Create timestamps based on the ``video_path`` provided.\n\n    Parameters:\n        video_path: A video path.\n        index: Index of the video stream.\n        normalize: If True, it will shift the PTS to make them start from 0. If false, the option does nothing.\n        use_video_provider_to_guess_fps: If True, use the video_provider to guess the video fps.\n            If not specified, the fps will be approximate from the first and last frame PTS.\n        video_provider: The video provider to use to get the information about the video timestamps/fps.\n\n    Returns:\n        An VideoTimestamps instance representing the video file.\n    \"\"\"\n\n    if not video_path.is_file():\n        raise FileNotFoundError(f'Invalid path for the video file: \"{video_path}\"')\n\n    pts_list, time_base, fps_from_video_provider = video_provider.get_pts(str(video_path.resolve()), index)\n    time_scale = 1 / time_base\n\n    if use_video_provider_to_guess_fps:\n        fps = fps_from_video_provider\n    else:\n        fps = None\n\n    timestamps = VideoTimestamps(\n        pts_list,\n        time_scale,\n        normalize,\n        fps\n    )\n    return timestamps\n</code></pre>"},{"location":"reference/video_timestamps/#video_timestamps.video_timestamps.VideoTimestamps.normalize","title":"<code>normalize(pts_list)</code>  <code>staticmethod</code>","text":"<p>Shift the pts_list to make them start from 0. This way, frame 0 will start at pts 0.</p> <p>Parameters:</p> Name Type Description Default <code>pts_list</code> <code>list[int]</code> <p>A list containing the Presentation Time Stamps (PTS) for all frames.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>The pts_list normalized.</p> Source code in <code>video_timestamps/video_timestamps.py</code> <pre><code>@staticmethod\ndef normalize(pts_list: list[int]) -&gt; list[int]:\n    \"\"\"Shift the pts_list to make them start from 0. This way, frame 0 will start at pts 0.\n\n    Parameters:\n        pts_list: A list containing the Presentation Time Stamps (PTS) for all frames.\n\n    Returns:\n        The pts_list normalized.\n    \"\"\"\n    if pts_list[0]:\n        return list(map(lambda pts: pts - pts_list[0], pts_list))\n    return pts_list\n</code></pre>"},{"location":"reference/video_timestamps/#video_timestamps.video_timestamps.VideoTimestamps.export_timestamps","title":"<code>export_timestamps(timestamps_filename, *, precision=9, precision_rounding=RoundingMethod.ROUND, use_fraction=False)</code>","text":"<pre><code>export_timestamps(\n    timestamps_filename: Path,\n    *,\n    use_fraction: Literal[True],\n) -&gt; None\n</code></pre><pre><code>export_timestamps(\n    timestamps_filename: Path,\n    *,\n    precision: int,\n    precision_rounding: RoundingCallType,\n    use_fraction: Literal[False] = False,\n) -&gt; None\n</code></pre> <p>Export the timestamps to timestamp format v2 file.</p> <p>Parameters:</p> Name Type Description Default <code>timestamps_filename</code> <code>Path</code> <p>The file path where the timestamps will be saved.</p> required <code>precision</code> <code>int | None</code> <p>Number of decimal places for timestamps (default: 9). The minimum value is 3. Note that for mkv file, you can always use 9 (the default value).</p> <p>Common values:</p> <ul> <li>3 means milliseconds</li> <li>6 means microseconds</li> <li>9 means nanoseconds</li> </ul> <code>9</code> <code>precision_rounding</code> <code>RoundingCallType | None</code> <p>Rounding method to use for timestamps (default: round).</p> <p>Examples:</p> <ul> <li>Timestamp: 453.4 ms,  precision=3, precision_rounding=RoundingMethod.ROUND --&gt; 453</li> <li>Timestamp: 453.4569 ms, precision=6, precision_rounding=RoundingMethod.ROUND --&gt; 453.457</li> </ul> <code>ROUND</code> <code>use_fraction</code> <code>bool</code> <p>The timestamps produced will be represented has a fraction (ex: \"30/2\") instead of decimal (ex: \"3.434\"). Note that this is not a conform to the specification.</p> <code>False</code> Source code in <code>video_timestamps/video_timestamps.py</code> <pre><code>def export_timestamps(\n    self,\n    timestamps_filename: Path,\n    *,\n    precision: int | None = 9,\n    precision_rounding: RoundingCallType | None = RoundingMethod.ROUND,\n    use_fraction: bool = False\n) -&gt; None:\n    \"\"\"Export the timestamps to [timestamp format v2 file](https://mkvtoolnix.download/doc/mkvmerge.html#d4e4659).\n\n    Parameters:\n        timestamps_filename: The file path where the timestamps will be saved.\n        precision: Number of decimal places for timestamps (default: 9).\n            The minimum value is 3. Note that for mkv file, you can always use 9 (the default value).\n\n            Common values:\n\n            - 3 means milliseconds\n            - 6 means microseconds\n            - 9 means nanoseconds\n        precision_rounding: Rounding method to use for timestamps (default: round).\n\n            Examples:\n\n            - Timestamp: 453.4 ms,  precision=3, precision_rounding=RoundingMethod.ROUND --&gt; 453\n            - Timestamp: 453.4569 ms, precision=6, precision_rounding=RoundingMethod.ROUND --&gt; 453.457\n        use_fraction: The timestamps produced will be represented has a fraction (ex: \"30/2\") instead of decimal (ex: \"3.434\").\n            Note that this is not a conform to the specification.\n    \"\"\"\n    if precision is not None and precision &lt; 3:\n        raise ValueError(\"The precision needs to be at least 3 (milliseconds).\")\n\n    with localcontext() as ctx:\n        with open(timestamps_filename, \"w\", encoding=\"utf-8\") as f:\n            f.write(\"# timestamp format v2\\n\")\n\n            for pts in self.pts_list:\n                if use_fraction:\n                    time_ms = pts / self.time_scale * 1000\n                    f.write(f\"{time_ms}\\n\")\n                else:\n                    assert precision is not None # Make mypy happy\n                    assert precision_rounding is not None # Make mypy happy\n\n                    time_precision = precision_rounding(pts / self.time_scale * pow(10, precision))\n                    time_ms = Fraction(time_precision, pow(10, precision - 3))\n\n                    # Be sure that decimal.Context.prec is high enough to do the conversion\n                    num_digits = len(str(time_ms.numerator // time_ms.denominator))\n                    ctx.prec = (precision - 3) + num_digits\n\n                    time_ms_d = Decimal(time_ms.numerator) / Decimal(time_ms.denominator)\n                    f.write(f\"{time_ms_d}\\n\")\n</code></pre>"},{"location":"reference/video_provider/abc_video_provider/","title":"ABCVideoProvider","text":"Source code in <code>video_timestamps/video_provider/abc_video_provider.pyi</code> <pre><code>class ABCVideoProvider:\n    def get_pts(self, filename: str, index: int) -&gt; tuple[list[int], Fraction, Fraction]:\n        \"\"\"\n        Parameters:\n            filename: A video path.\n            index: Index of the video stream.\n\n        Returns:\n            A tuple containing these 3 informations:\n\n                1. A list of each frame's pts. The last pts correspond to the pts of the last frame + it's duration.\n                2. The time_base.\n                3. The fps.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/video_provider/abc_video_provider/#video_timestamps.video_provider.abc_video_provider.ABCVideoProvider.get_pts","title":"<code>get_pts(filename, index)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>A video path.</p> required <code>index</code> <code>int</code> <p>Index of the video stream.</p> required <p>Returns:</p> Type Description <code>tuple[list[int], Fraction, Fraction]</code> <p>A tuple containing these 3 informations:</p> <ol> <li>A list of each frame's pts. The last pts correspond to the pts of the last frame + it's duration.</li> <li>The time_base.</li> <li>The fps.</li> </ol> Source code in <code>video_timestamps/video_provider/abc_video_provider.pyi</code> <pre><code>def get_pts(self, filename: str, index: int) -&gt; tuple[list[int], Fraction, Fraction]:\n    \"\"\"\n    Parameters:\n        filename: A video path.\n        index: Index of the video stream.\n\n    Returns:\n        A tuple containing these 3 informations:\n\n            1. A list of each frame's pts. The last pts correspond to the pts of the last frame + it's duration.\n            2. The time_base.\n            3. The fps.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/video_provider/best_source_video_provider/","title":"BestSourceVideoProvider","text":"<p>               Bases: <code>ABCVideoProvider</code></p> <p>Video provider that is based on BestSource.</p> Source code in <code>video_timestamps/video_provider/best_source_video_provider.pyi</code> <pre><code>class BestSourceVideoProvider(ABCVideoProvider):\n    \"\"\"\n    Video provider that is based on [BestSource](https://github.com/vapoursynth/bestsource).\n    \"\"\"\n    def __init__(self) -&gt; None:\n        ...\n    def get_pts(self, filename: str, index: int) -&gt; tuple[list[int], Fraction, Fraction]:\n        ...\n</code></pre>"},{"location":"reference/video_provider/ffms2_video_provider/","title":"FFMS2VideoProvider","text":"<p>               Bases: <code>ABCVideoProvider</code></p> <p>Video provider that is based on FFMS2.</p> Source code in <code>video_timestamps/video_provider/ffms2_video_provider.pyi</code> <pre><code>class FFMS2VideoProvider(ABCVideoProvider):\n    \"\"\"\n    Video provider that is based on [FFMS2](https://github.com/FFMS/ffms2).\n    \"\"\"\n    def __init__(self) -&gt; None:\n        ...\n    def get_pts(self, filename: str, index: int) -&gt; tuple[list[int], Fraction, Fraction]:\n        ...\n</code></pre>"}]}